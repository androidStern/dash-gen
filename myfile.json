[
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var R = {};\n\n        // Internal Functions and Properties\n        // ---------------------------------",
    "ctx": {
      "type": "declaration",
      "name": "R",
      "value": "{}",
      "string": "R"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A reference to the <code>undefined</code> value.</p><p>Note that this is defined as the result of calling an empty function because JSHint<br />complains about these constructs:</p><p>var undef = void 0;<br />var undef = undefined;</p>",
      "summary": "<p>A reference to the <code>undefined</code> value.</p>",
      "body": "<p>Note that this is defined as the result of calling an empty function because JSHint<br />complains about these constructs:</p><p>var undef = void 0;<br />var undef = undefined;</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var undef = (function () {})();",
    "ctx": {
      "type": "declaration",
      "name": "undef",
      "value": "(function () {})()",
      "string": "undef"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "oldName",
        "description": "The name of the public function to alias."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A function decorated with the `is`, `are`, and `and` methods. Create an alias for the `oldName function by invoking any of these methods an passing it a\nstring with the `newName` parameter."
      },
      {
        "type": "example",
        "string": "\n// Create an alias for `each` named `forEach`\naliasFor('each').is('forEach');"
      }
    ],
    "description": {
      "full": "<p>Creates an alias for a public function.</p>",
      "summary": "<p>Creates an alias for a public function.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var aliasFor = function (oldName) {\n            var fn = function (newName) {\n                R[newName] = R[oldName];\n                return fn;\n            };\n            fn.is = fn.are = fn.and = fn;\n            return fn;\n        };",
    "ctx": {
      "type": "function",
      "name": "aliasFor",
      "string": "aliasFor()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "Arguments",
          "Array"
        ],
        "name": "args",
        "description": "The array or arguments object to consider."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "[from=0]",
        "description": "The array index to slice from, inclusive."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "[to=args.length]",
        "description": "The array index to slice to, exclusive."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new, sliced array."
      },
      {
        "type": "example",
        "string": "\n_slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n\nvar firstThreeArgs = function(a, b, c, d) {\n  return _slice(arguments, 0, 3);\n};\nfirstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]"
      }
    ],
    "description": {
      "full": "<p>An optimized, private array <code>slice</code> implementation.</p>",
      "summary": "<p>An optimized, private array <code>slice</code> implementation.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var _slice = function (args, from, to) {\n            from = (typeof from === \"number\" ) ? from : 0;\n            to = (typeof to === \"number\" ) ? to : args.length;\n            var length = to - from,\n                arr = new Array(length),\n                i = -1;\n\n            while (++i < length) {\n                arr[i] = args[from + i];\n            }\n            return arr;\n        };",
    "ctx": {
      "type": "function",
      "name": "_slice",
      "string": "_slice()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "Array",
          "Arguments"
        ],
        "name": "[set1=[]]",
        "description": "An array-like object."
      },
      {
        "type": "param",
        "types": [
          "Array",
          "Arguments"
        ],
        "name": "[set2=[]]",
        "description": "An array-like object."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new, merged array."
      },
      {
        "type": "example",
        "string": "\nconcat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]"
      }
    ],
    "description": {
      "full": "<p>Private <code>concat</code> function to merge two array-like objects.</p>",
      "summary": "<p>Private <code>concat</code> function to merge two array-like objects.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var concat = function(set1, set2) {\n            set1 = set1 || [];\n            set2 = set2 || [];\n            var length1 = set1.length,\n                length2 = set2.length,\n                result = new Array(length1 + length2);\n\n            for (var i = 0; i < length1; i++) {\n                result[i] = set1[i];\n            }\n            for (i = 0; i < length2; i++) {\n                result[i + length1] = set2[i];\n            }\n            return result;\n        };\n\n        // Private reference to toString function.\n        var toString = Object.prototype.toString;",
    "ctx": {
      "type": "function",
      "name": "concat",
      "string": "concat()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "val",
        "description": "The object to test."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` if `val` is an array, `false` otherwise."
      },
      {
        "type": "example",
        "string": "\nisArray([]); //=> true\nisArray(true); //=> false\nisArray({}); //=> false"
      }
    ],
    "description": {
      "full": "<p>Tests whether or not an object is an array.</p>",
      "summary": "<p>Tests whether or not an object is an array.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var isArray = Array.isArray || function (val) {\n            return val && val.length >= 0 && toString.call(val) === \"[object Array]\";\n        };",
    "ctx": {
      "type": "declaration",
      "name": "isArray",
      "value": "Array.isArray || function (val) {",
      "string": "isArray"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to curry."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "[fnArity=fn.length]",
        "description": "An optional arity for the returned function."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new, curried function."
      },
      {
        "type": "example",
        "string": "\nvar addFourNumbers = function(a, b, c, d) {\n  return a + b + c + d;\n};\n\nvar curriedAddFourNumbers = curry(addFourNumbers);\nvar f = curriedAddFourNumbers(1, 2);\nvar g = f(3);\ng(4);//=> 10"
      }
    ],
    "description": {
      "full": "<p>Creates a new version of <code>fn</code> that, when invoked, will return either:</p><ul>\n<li>A new function ready to accept one or more of <code>fn</code>&#39;s remaining arguments, if all of<br /><code>fn</code>&#39;s expected arguments have not yet been provided</li>\n<li><code>fn</code>&#39;s result if all of its expected arguments have been provided</li>\n</ul>\n<p>Optionally, you may provide an arity for the returned function.</p>",
      "summary": "<p>Creates a new version of <code>fn</code> that, when invoked, will return either:</p><ul>\n<li>A new function ready to accept one or more of <code>fn</code>&#39;s remaining arguments, if all of<br /><code>fn</code>&#39;s expected arguments have not yet been provided</li>\n<li><code>fn</code>&#39;s result if all of its expected arguments have been provided</li>\n</ul>\n",
      "body": "<p>Optionally, you may provide an arity for the returned function.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var curry = R.curry = function (fn, fnArity) {\n            fnArity = typeof fnArity === \"number\" ? fnArity : fn.length;\n            function recurry(args) {\n                return arity(Math.max(fnArity - (args && args.length || 0), 0), function () {\n                    if (arguments.length === 0) { throw NO_ARGS_EXCEPTION; }\n                    var newArgs = concat(args, arguments);\n                    if (newArgs.length >= fnArity) {\n                        return fn.apply(this, newArgs);\n                    }\n                    else {\n                        return recurry(newArgs);\n                    }\n                });\n            }\n\n            return recurry([]);\n        };\n\n        var NO_ARGS_EXCEPTION = new TypeError('Function called with no arguments');",
    "ctx": {
      "type": "declaration",
      "name": "curry",
      "value": "R.curry = function (fn, fnArity) {",
      "string": "curry"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to curry."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` if `val` is an array, `false` otherwise."
      },
      {
        "type": "example",
        "string": "\nvar addTwo = function(a, b) {\n  return a + b;\n};\nvar curriedAddTwo = curry2(addTwo);"
      }
    ],
    "description": {
      "full": "<p>Optimized internal two-arity curry function.</p>",
      "summary": "<p>Optimized internal two-arity curry function.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function curry2(fn) {\n            return function(a, b) {\n                switch (arguments.length) {\n                    case 0: throw NO_ARGS_EXCEPTION;\n                    case 1: return function(b) {\n                        return fn(a, b);\n                    };\n                }\n                return fn(a, b);\n            };\n        }",
    "ctx": {
      "type": "function",
      "name": "curry2",
      "string": "curry2()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to curry."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` if `val` is an array, `false` otherwise."
      },
      {
        "type": "example",
        "string": "\nvar addThree = function(a, b, c) {\n  return a + b + c;\n};\nvar curriedAddThree = curry2(addThree);"
      }
    ],
    "description": {
      "full": "<p>Optimized internal three-arity curry function.</p>",
      "summary": "<p>Optimized internal three-arity curry function.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function curry3(fn) {\n            return function(a, b, c) {\n                switch (arguments.length) {\n                    case 0: throw NO_ARGS_EXCEPTION;\n                    case 1: return curry2(function(b, c) {\n                        return fn(a, b, c);\n                    });\n                    case 2: return function(c) {\n                        return fn(a, b, c);\n                    };\n                }\n                return fn(a, b, c);\n            };\n        }",
    "ctx": {
      "type": "function",
      "name": "curry3",
      "string": "curry3()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "methodName",
        "description": "The name of the method to check for."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "obj",
        "description": "The object to test."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` has a given method, `false` otherwise."
      },
      {
        "type": "example",
        "string": "\nvar person = { name: 'John' };\nperson.shout = function() { alert(this.name); };\n\nhasMethod('shout', person); //=> true\nhasMethod('foo', person); //=> false"
      }
    ],
    "description": {
      "full": "<p>Private function that determines whether or not a provided object has a given method.<br />Does not ignore methods stored on the object&#39;s prototype chain. Used for dynamically<br />dispatching Ramda methods to non-Array objects.</p>",
      "summary": "<p>Private function that determines whether or not a provided object has a given method.<br />Does not ignore methods stored on the object&#39;s prototype chain. Used for dynamically<br />dispatching Ramda methods to non-Array objects.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var hasMethod = function (methodName, obj) {\n            return obj && !isArray(obj) && typeof obj[methodName] === 'function';\n        };",
    "ctx": {
      "type": "function",
      "name": "hasMethod",
      "string": "hasMethod()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Internal"
      },
      {
        "type": "param",
        "types": [
          "TODO"
        ],
        "name": "n",
        "description": "TODO"
      },
      {
        "type": "return",
        "types": [
          "string"
        ],
        "description": "TODO"
      },
      {
        "type": "example",
        "string": "\nTODO"
      }
    ],
    "description": {
      "full": "<p>TODO</p>",
      "summary": "<p>TODO</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var mkArgStr = function (n) {\n            var arr = [], idx = -1;\n            while (++idx < n) {\n                arr[idx] = \"arg\" + idx;\n            }\n            return arr.join(\", \");\n        };",
    "ctx": {
      "type": "function",
      "name": "mkArgStr",
      "string": "mkArgStr()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "The desired arity of the new function."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. The new function is guaranteed to be of arity `n`."
      },
      {
        "type": "example",
        "string": "\nvar takesTwoArgs = function(a, b) {\n  return [a, b];\n};\ntakesTwoArgs.length; //=> 2\ntakesTwoArgs(1, 2); //=> [1, 2]\n\nvar takesOneArg = ramda.nAry(1, takesTwoArgs);\ntakesOneArg.length; //=> 1\n// Only `n` arguments are passed to the wrapped function\ntakesOneArg(1, 2); //=> [1, undefined]"
      }
    ],
    "description": {
      "full": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly <code>n</code><br />parameters. Any extraneous parameters will not be passed to the supplied function.</p>",
      "summary": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly <code>n</code><br />parameters. Any extraneous parameters will not be passed to the supplied function.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var nAry = R.nAry = (function () {\n            var cache = {\n                0: function (func) {\n                    return function () {\n                        return func.call(this);\n                    };\n                },\n                1: function (func) {\n                    return function (arg0) {\n                        return func.call(this, arg0);\n                    };\n                },\n                2: function (func) {\n                    return function (arg0, arg1) {\n                        return func.call(this, arg0, arg1);\n                    };\n                },\n                3: function (func) {\n                    return function (arg0, arg1, arg2) {\n                        return func.call(this, arg0, arg1, arg2);\n                    };\n                }\n            };\n\n\n            //     For example:\n            //     cache[5] = function(func) {\n            //         return function(arg0, arg1, arg2, arg3, arg4) {\n            //             return func.call(this, arg0, arg1, arg2, arg3, arg4);\n            //         }\n            //     };\n\n            var makeN = function (n) {\n                var fnArgs = mkArgStr(n);\n                var body = [\n                        \"    return function(\" + fnArgs + \") {\",\n                        \"        return func.call(this\" + (fnArgs ? \", \" + fnArgs : \"\") + \");\",\n                    \"    }\"\n                ].join(\"\\n\");\n                return new Function(\"func\", body);\n            };\n\n            return function (n, fn) {\n                return (cache[n] || (cache[n] = makeN(n)))(fn);\n            };\n        }());",
    "ctx": {
      "type": "declaration",
      "name": "nAry",
      "value": "R.nAry = (function () {",
      "string": "nAry"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. The new function is guaranteed to be of arity 1."
      },
      {
        "type": "example",
        "string": "\nvar takesTwoArgs = function(a, b) {\n  return [a, b];\n};\ntakesTwoArgs.length; //=> 2\ntakesTwoArgs(1, 2); //=> [1, 2]\n\nvar takesOneArg = ramda.unary(1, takesTwoArgs);\ntakesOneArg.length; //=> 1\n// Only 1 argument is passed to the wrapped function\ntakesOneArg(1, 2); //=> [1, undefined]"
      }
    ],
    "description": {
      "full": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly 1<br />parameter. Any extraneous parameters will not be passed to the supplied function.</p>",
      "summary": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly 1<br />parameter. Any extraneous parameters will not be passed to the supplied function.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.unary = function (fn) {\n            return nAry(1, fn);\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "unary",
      "string": "R.unary()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. The new function is guaranteed to be of arity 2."
      },
      {
        "type": "example",
        "string": "\nvar takesThreeArgs = function(a, b, c) {\n  return [a, b, c];\n};\ntakesThreeArgs.length; //=> 3\ntakesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n\nvar takesTwoArgs = ramda.binary(1, takesThreeArgs);\ntakesTwoArgs.length; //=> 2\n// Only 2 arguments are passed to the wrapped function\ntakesTwoArgs(1, 2, 3); //=> [1, 2, undefined]"
      }
    ],
    "description": {
      "full": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly 2<br />parameters. Any extraneous parameters will not be passed to the supplied function.</p>",
      "summary": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly 2<br />parameters. Any extraneous parameters will not be passed to the supplied function.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var binary = R.binary = function (fn) {\n            return nAry(2, fn);\n        };",
    "ctx": {
      "type": "declaration",
      "name": "binary",
      "value": "R.binary = function (fn) {",
      "string": "binary"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "The desired arity of the returned function."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. The new function is guaranteed to be of arity `n`."
      },
      {
        "type": "example",
        "string": "\nvar takesTwoArgs = function(a, b) {\n  return [a, b];\n};\ntakesTwoArgs.length; //=> 2\ntakesTwoArgs(1, 2); //=> [1, 2]\n\nvar takesOneArg = ramda.unary(1, takesTwoArgs);\ntakesOneArg.length; //=> 1\n// All arguments are passed through to the wrapped function\ntakesOneArg(1, 2); //=> [1, 2]"
      }
    ],
    "description": {
      "full": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly <code>n</code><br />parameters. Unlike <code>nAry</code>, which passes only <code>n</code> arguments to the wrapped function,<br />functions produced by <code>arity</code> will pass all provided arguments to the wrapped function.</p>",
      "summary": "<p>Wraps a function of any arity (including nullary) in a function that accepts exactly <code>n</code><br />parameters. Unlike <code>nAry</code>, which passes only <code>n</code> arguments to the wrapped function,<br />functions produced by <code>arity</code> will pass all provided arguments to the wrapped function.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var arity = R.arity = (function () {\n            var cache = {\n                0: function (func) {\n                    return function () {\n                        return func.apply(this, arguments);\n                    };\n                },\n                1: function (func) {\n                    return function (arg0) {\n                        return func.apply(this, arguments);\n                    };\n                },\n                2: function (func) {\n                    return function (arg0, arg1) {\n                        return func.apply(this, arguments);\n                    };\n                },\n                3: function (func) {\n                    return function (arg0, arg1, arg2) {\n                        return func.apply(this, arguments);\n                    };\n                }\n            };\n\n            //     For example:\n            //     cache[5] = function(func) {\n            //         return function(arg0, arg1, arg2, arg3, arg4) {\n            //             return func.apply(this, arguments);\n            //         }\n            //     };\n\n            var makeN = function (n) {\n                var fnArgs = mkArgStr(n);\n                var body = [\n                        \"    return function(\" + fnArgs + \") {\",\n                    \"        return func.apply(this, arguments);\",\n                    \"    }\"\n                ].join(\"\\n\");\n                return new Function(\"func\", body);\n            };\n\n            return function (n, fn) {\n                return (cache[n] || (cache[n] = makeN(n)))(fn);\n            };\n        }());",
    "ctx": {
      "type": "declaration",
      "name": "arity",
      "value": "R.arity = (function () {",
      "string": "arity"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "The name of the method to wrap."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "The object to search for the `name` method."
      },
      {
        "type": "param",
        "types": [
          "[len]"
        ],
        "name": "The",
        "description": "desired arity of the wrapped method."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function or `undefined` if the specified method is not found."
      },
      {
        "type": "example",
        "string": "\n\nvar charAt = ramda.invoker('charAt', String.prototype);\ncharAt(6, 'abcdefghijklm'); //=> 'g'\n\nvar join = ramda.invoker('join', Array.prototype);\nvar firstChar = charAt(0);\njoin('', ramda.map(firstChar, [\"light\", \"ampliifed\", \"stimulated\", \"emission\", \"radiation\"]));\n//=> 'laser'"
      }
    ],
    "description": {
      "full": "<p>Turns a named method of an object (or object prototype) into a function that can be<br />called directly. Passing the optional <code>len</code> parameter restricts the returned function to<br />the initial <code>len</code> parameters of the method.</p><p>The returned function is curried and accepts <code>len + 1</code> parameters (or <code>method.length + 1</code><br />when <code>len</code> is not specified), and the final parameter is the target object.</p>",
      "summary": "<p>Turns a named method of an object (or object prototype) into a function that can be<br />called directly. Passing the optional <code>len</code> parameter restricts the returned function to<br />the initial <code>len</code> parameters of the method.</p>",
      "body": "<p>The returned function is curried and accepts <code>len + 1</code> parameters (or <code>method.length + 1</code><br />when <code>len</code> is not specified), and the final parameter is the target object.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var invoker = R.invoker = function (name, obj, len) {\n            var method = obj[name];\n            var length = len === undef ? method.length : len;\n            return method && curry(function () {\n                if (arguments.length) {\n                    var target = Array.prototype.pop.call(arguments);\n                    var targetMethod = target[name];\n                    if (targetMethod == method) {\n                        return targetMethod.apply(target, arguments);\n                    }\n                }\n                return undef;\n            }, length + 1);\n        };",
    "ctx": {
      "type": "declaration",
      "name": "invoker",
      "value": "R.invoker = function (name, obj, len) {",
      "string": "invoker"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "param",
        "types": [
          "...Function"
        ],
        "name": "transformers",
        "description": "A variable number of transformer functions"
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "The wrapped function."
      },
      {
        "type": "example",
        "string": "\nvar double = function(y) { return y * 2; };\nvar square = function(x) { return x * x; };\nvar add = function(a, b) { return a + b; };\n// Adds any number of arguments together\nvar addAll = function() {\n  return ramda.reduce(add, 0, arguments);\n};\n\n// Basic example\nvar addDoubleAndSquare = ramda.useWith(addAll, double, square);\n\naddDoubleAndSquare(10, 5); //≅ addAll(double(10), square(5));\n//=> 125\n\n// Example of passing more arguments than transformers\naddDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), 100);\n//=> 225\n\n// But if you're expecting additional arguments that don't need transformation, it's best\n// to pass transformer functions so the resulting function has the correct arity\nvar addDoubleAndSquareWithExtraParams = ramda.useWith(addAll, double, square, ramda.identity);\naddDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), ramda.identity(100));\n//=> 225"
      }
    ],
    "description": {
      "full": "<p>Accepts a function <code>fn</code> and any number of transformer functions and returns a new<br />function. When the new function is invoked, it calls the function <code>fn</code> with parameters<br />consisting of the result of calling each supplied handler on successive arguments to the<br />new function. For example:</p><pre><code class=\"lang-javascript\">  var useWithExample = invoke(someFn, transformerFn1, transformerFn2);\n\n  // This invocation:\n  useWithExample(&#39;x&#39;, &#39;y&#39;);\n  // Is functionally equivalent to:\n  someFn(transformerFn1(&#39;x&#39;), transformerFn2(&#39;y&#39;))\n</code></pre>\n<p>If more arguments are passed to the returned function than transformer functions, those<br />arguments are passed directly to <code>fn</code> as additional parameters. If you expect additional<br />arguments that don&#39;t need to be transformed, although you can ignore them, it&#39;s best to<br />pass an identity function so that the new function reports the correct arity.</p>",
      "summary": "<p>Accepts a function <code>fn</code> and any number of transformer functions and returns a new<br />function. When the new function is invoked, it calls the function <code>fn</code> with parameters<br />consisting of the result of calling each supplied handler on successive arguments to the<br />new function. For example:</p>",
      "body": "<pre><code class=\"lang-javascript\">  var useWithExample = invoke(someFn, transformerFn1, transformerFn2);\n\n  // This invocation:\n  useWithExample(&#39;x&#39;, &#39;y&#39;);\n  // Is functionally equivalent to:\n  someFn(transformerFn1(&#39;x&#39;), transformerFn2(&#39;y&#39;))\n</code></pre>\n<p>If more arguments are passed to the returned function than transformer functions, those<br />arguments are passed directly to <code>fn</code> as additional parameters. If you expect additional<br />arguments that don&#39;t need to be transformed, although you can ignore them, it&#39;s best to<br />pass an identity function so that the new function reports the correct arity.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var useWith = R.useWith = function (fn",
    "ctx": {
      "type": "declaration",
      "name": "useWith",
      "value": "R.useWith = function (fn",
      "string": "useWith"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>transformers</p>",
      "summary": "<p>transformers</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "{\n            var transformers = _slice(arguments, 1);\n            var tlen = transformers.length;\n            return curry(arity(tlen, function () {\n                var args = [], idx = -1;\n                while (++idx < tlen) {\n                    args.push(transformers[idx](arguments[idx]));\n                }\n                return fn.apply(this, args.concat(_slice(arguments, tlen)));\n            }));\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A two-step version of the `useWith` function.  This would allow us to write `project`, currently written\n        // as `useWith(map, pickAll, identity)`, as, instead, `use(map).over(pickAll, identity)`, which is a bit\n        // more explicit.\n        // TODO: One of these versions should be eliminated eventually.  So not worrying about the duplication for now.\n        R.use = function (fn) {\n            return {\n                over: function ("
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ransformers</p>",
      "summary": "<p>ransformers</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "{\n                    var transformers = _slice(arguments, 0);\n                    var tlen = transformers.length;\n                    return curry(arity(tlen, function () {\n                        var args = [], idx = -1;\n                        while (++idx < tlen) {\n                            args.push(transformers[idx](arguments[idx]));\n                        }\n                        return fn.apply(this, args.concat(_slice(arguments, tlen)));\n                    }));\n                }\n            };\n        };"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke. Receives one argument, `value`."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The original list."
      },
      {
        "type": "example",
        "string": "\nramda.each(function(num) {\n  console.log(num + 100);\n}, [1, 2, 3]); //=> [1, 2, 3]\n//-> 101\n//-> 102\n//-> 103"
      }
    ],
    "description": {
      "full": "<p>Iterate over an input <code>list</code>, calling a provided function <code>fn</code> for each element in the<br />list.</p><p><code>fn</code> receives one argument: <em>(value)</em>.</p><p>Note: <code>ramda.each</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.forEach</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description</a></p><p>Also note that, unlike <code>Array.prototype.forEach</code>, Ramda&#39;s <code>each</code> returns the original<br />array.</p>",
      "summary": "<p>Iterate over an input <code>list</code>, calling a provided function <code>fn</code> for each element in the<br />list.</p>",
      "body": "<p><code>fn</code> receives one argument: <em>(value)</em>.</p><p>Note: <code>ramda.each</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.forEach</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description</a></p><p>Also note that, unlike <code>Array.prototype.forEach</code>, Ramda&#39;s <code>each</code> returns the original<br />array.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var each = R.each = function (fn, list) {\n            function _each(list) {\n                var idx = -1, len = list.length;\n                while (++idx < len) {\n                    fn(list[idx]);\n                }\n                // i can't bear not to return *something*\n                return list;\n            }\n            return arguments.length < 2 ? _each : _each(list);\n        };",
    "ctx": {
      "type": "declaration",
      "name": "each",
      "value": "R.each = function (fn, list) {",
      "string": "each"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "alias",
        "string": "forEach"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke. Receives three arguments: (`value`, `index`, `list`)."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The original list."
      },
      {
        "type": "example",
        "string": "\n// Note that having access to the original `list` allows for mutation. While you *can* do\n// this, it's very un-functional behavior:\nramda.each.idx(function(num, idx, list) {\n  list[idx] = num + 100;\n}, [1, 2, 3]); //=> [101, 102, 103]"
      }
    ],
    "description": {
      "full": "<p>Like <code>each</code>, but but passes additional parameters to the predicate function.</p><p><code>fn</code> receives three arguments: <em>(value, index, list)</em>.</p><p>Note: <code>ramda.each.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.forEach</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description</a></p><p>Also note that, unlike <code>Array.prototype.forEach</code>, Ramda&#39;s <code>each</code> returns the original<br />array.</p>",
      "summary": "<p>Like <code>each</code>, but but passes additional parameters to the predicate function.</p>",
      "body": "<p><code>fn</code> receives three arguments: <em>(value, index, list)</em>.</p><p>Note: <code>ramda.each.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.forEach</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description</a></p><p>Also note that, unlike <code>Array.prototype.forEach</code>, Ramda&#39;s <code>each</code> returns the original<br />array.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "each.idx = function (fn, list) {\n            function _eachIdx(list) {\n                var idx = -1, len = list.length;\n                while (++idx < len) {\n                    fn(list[idx], idx, list);\n                }\n                // i can't bear not to return *something*\n                return list;\n            }\n            return arguments.length < 2 ? _eachIdx : _eachIdx(list);\n        };\n\n        aliasFor(\"each\").is(\"forEach\");",
    "ctx": {
      "type": "method",
      "receiver": "each",
      "name": "idx",
      "string": "each.idx()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to clone."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new copy of the original list."
      },
      {
        "type": "example",
        "string": "\nvar numbers = [1, 2, 3];\nvar numbersClone = ramda.clone(numbers); //=> [1, 2, 3]\nnumbers === numbersClone; //=> false\n\n// Note that this is a shallow clone--it does not clone complex values:\nvar objects = [{}, {}, {}];\nvar objectsClone = ramda.clone(objects);\nobjects[0] === objectsClone[0]; //=> true"
      }
    ],
    "description": {
      "full": "<p>Creates a shallow copy of an array.</p>",
      "summary": "<p>Creates a shallow copy of an array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var clone = R.clone = function(list) {\n            return _slice(list);\n        };\n\n        // Core Functions\n        // --------------\n        //",
    "ctx": {
      "type": "declaration",
      "name": "clone",
      "value": "R.clone = function(list) {",
      "string": "clone"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arr",
        "description": "The array to consider."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` if the `arr` argument has a length of 0 or if `arr` is a falsy value (e.g. undefined)."
      },
      {
        "type": "example",
        "string": "\nramda.isEmpty([1, 2, 3]); //=> false\nramda.isEmpty([]); //=> true\nramda.isEmpty(); //=> true\nramda.isEmpty(null); //=> true"
      }
    ],
    "description": {
      "full": "<p>Reports whether an array is empty.</p>",
      "summary": "<p>Reports whether an array is empty.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var isEmpty = R.isEmpty = function (arr) {\n            return !arr || !arr.length;\n        };",
    "ctx": {
      "type": "declaration",
      "name": "isEmpty",
      "value": "R.isEmpty = function (arr) {",
      "string": "isEmpty"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "alias",
        "string": "cons"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "el",
        "description": "The item to add to the head of the output list."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arr",
        "description": "The array to add to the tail of the output list."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array."
      },
      {
        "type": "example",
        "string": "\nramda.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']"
      }
    ],
    "description": {
      "full": "<p>Returns a new list with the given element at the front, followed by the contents of the<br />list.</p>",
      "summary": "<p>Returns a new list with the given element at the front, followed by the contents of the<br />list.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var prepend = R.prepend = function (el, arr) {\n            return concat([el], arr);\n        };\n\n        aliasFor(\"prepend\").is(\"cons\");",
    "ctx": {
      "type": "declaration",
      "name": "prepend",
      "value": "R.prepend = function (el, arr) {",
      "string": "prepend"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "alias",
        "string": "car, first"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "[arr=[]]",
        "description": "The array to consider."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The first element of the list, or `undefined` if the list is empty."
      },
      {
        "type": "example",
        "string": "\nramda.head(['fi', 'fo', 'fum']); //=> 'fi'"
      }
    ],
    "description": {
      "full": "<p>Returns the first element in a list.</p>",
      "summary": "<p>Returns the first element in a list.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var head = R.head = function (arr) {\n            arr = arr || [];\n            return arr[0];\n        };\n\n        aliasFor(\"head\").is(\"car\").and(\"first\");",
    "ctx": {
      "type": "declaration",
      "name": "head",
      "value": "R.head = function (arr) {",
      "string": "head"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "[arr=[]]",
        "description": "The array to consider."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The last element of the list, or `undefined` if the list is empty."
      },
      {
        "type": "example",
        "string": "\nramda.last(['fi', 'fo', 'fum']); //=> 'fum'"
      }
    ],
    "description": {
      "full": "<p>Returns the last element from a list.</p>",
      "summary": "<p>Returns the last element from a list.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.last = function (arr) {\n            arr = arr || [];\n            return arr[arr.length - 1];\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "last",
      "string": "R.last()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "alias",
        "string": "cdr"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "[arr=[]]",
        "description": "The array to consider."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array containing all but the first element of the input list, or an empty list if the input list is a falsy value (e.g. `undefined`)."
      },
      {
        "type": "example",
        "string": "\nramda.tail(['fi', 'fo', 'fum']); //=> ['fo', 'fum']"
      }
    ],
    "description": {
      "full": "<p>Returns all but the first element of a list. If the list provided has the <code>tail</code> method,<br />it will instead return <code>list.tail()</code>.</p>",
      "summary": "<p>Returns all but the first element of a list. If the list provided has the <code>tail</code> method,<br />it will instead return <code>list.tail()</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var tail = R.tail = function (arr) {\n            arr = arr || [];\n            if (hasMethod('tail', arr)) {\n                return arr.tail();\n            }\n            return (arr.length > 1) ? _slice(arr, 1) : [];\n        };\n\n        aliasFor(\"tail\").is(\"cdr\");",
    "ctx": {
      "type": "declaration",
      "name": "tail",
      "value": "R.tail = function (arr) {",
      "string": "tail"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "x",
        "description": "The element to consider."
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "`true` if `x` is an atom, and `false` otherwise."
      },
      {
        "type": "example",
        "string": "\nramda.isAtom([]); //=> false\nramda.isAtom(null); //=> false\nramda.isAtom(undefined); //=> false\n\nramda.isAtom(0); //=> true\nramda.isAtom(''); //=> true\nramda.isAtom('test'); //=> true\nramda.isAtom({}); //=> true"
      }
    ],
    "description": {
      "full": "<p>Returns <code>true</code> if the argument is an atom; <code>false</code> otherwise. An atom is defined as any<br />value that is not an array, <code>undefined</code>, or <code>null</code>.</p>",
      "summary": "<p>Returns <code>true</code> if the argument is an atom; <code>false</code> otherwise. An atom is defined as any<br />value that is not an array, <code>undefined</code>, or <code>null</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.isAtom = function (x) {\n            return x != null && !isArray(x);\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "isAtom",
      "string": "R.isAtom()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "alias",
        "string": "push"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "el",
        "description": "The element to add to the end of the new list."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list whose contents will be added to the beginning of the output list."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new list containing the contents of the old list followed by `el`."
      },
      {
        "type": "example",
        "string": "\nramda.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\nramda.append('tests', []); //=> ['tests']\nramda.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]"
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing the contents of the given list, followed by the given<br />element.</p>",
      "summary": "<p>Returns a new list containing the contents of the given list, followed by the given<br />element.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var append = R.append = function(el, list) {\n            return concat(list, [el]);\n        };\n\n        aliasFor(\"append\").is(\"push\");",
    "ctx": {
      "type": "declaration",
      "name": "append",
      "value": "R.append = function(el, list) {",
      "string": "append"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list1",
        "description": "The first list to merge."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list2",
        "description": "The second set to merge."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array consisting of the contents of `list1` followed by the contents of `list2`. If, instead of an {Array} for `list1`, you pass an object with a `concat`\nmethod on it, `concat` will call `list1.concat` and it the value of `list2`."
      },
      {
        "type": "example",
        "string": "\nramda.concat([], []); //=> []\nramda.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\nramda.concat(\"ABC\", \"DEF\"); // \"ABCDEF\""
      }
    ],
    "description": {
      "full": "<p>Returns a new list consisting of the elements of the first list followed by the elements<br />of the second.</p>",
      "summary": "<p>Returns a new list consisting of the elements of the first list followed by the elements<br />of the second.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.concat = curry2(function(set1, set2) {\n            return (hasMethod('concat', set1)) ? set1.concat(set2) : concat(set1, set2);\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "concat",
      "value": "curry2(function(set1, set2) {",
      "string": "R.concat"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Core"
      },
      {
        "type": "alias",
        "string": "I"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "x",
        "description": "The value to return."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The input value, `x`."
      },
      {
        "type": "example",
        "string": "\nramda.identity(1); //=> 1\n\nvar obj = {};\nramda.identity(obj) === obj; //=> true"
      }
    ],
    "description": {
      "full": "<p>A function that does nothing but return the parameter supplied to it. Good as a default<br />or placeholder function.</p>",
      "summary": "<p>A function that does nothing but return the parameter supplied to it. Good as a default<br />or placeholder function.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var identity = R.identity = function (x) {\n            return x;\n        };\n\n        aliasFor(\"identity\").is(\"I\");",
    "ctx": {
      "type": "declaration",
      "name": "identity",
      "value": "R.identity = function (x) {",
      "string": "identity"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke. Passed one argument, the current value of `n`."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "A value between `0` and `n - 1`. Increments after each function call."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "An array containing the return values of all calls to `fn`."
      },
      {
        "type": "example",
        "string": "\nramda.times(function(n) { return n; }, 5); //=> [0, 1, 2, 3, 4]"
      }
    ],
    "description": {
      "full": "<p>Calls an input function <code>n</code> times, returning an array containing the results of those<br />function calls.</p><p><code>fn</code> is passed one argument: The current value of <code>n</code>, which begins at <code>0</code> and is<br />gradually incremented to <code>n - 1</code>.</p>",
      "summary": "<p>Calls an input function <code>n</code> times, returning an array containing the results of those<br />function calls.</p>",
      "body": "<p><code>fn</code> is passed one argument: The current value of <code>n</code>, which begins at <code>0</code> and is<br />gradually incremented to <code>n - 1</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.times = curry2(function (fn, n) {\n            var arr = new Array(n);\n            var i = -1;\n            while (++i < n) {\n                arr[i] = fn(i);\n            }\n            return arr;\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "times",
      "value": "curry2(function (fn, n) {",
      "string": "R.times"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Array"
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "value",
        "description": "The value to repeat."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "The desired size of the output list."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array containing `n` `value`s."
      },
      {
        "type": "example",
        "string": "\nramda.repeatN('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n\nvar obj = {};\nvar repeatedObjs = ramda.repeatN(obj, 5); //=> [{}, {}, {}, {}, {}]\nrepeatedObjs[0] === repeatedObjs[1]; //=> true"
      }
    ],
    "description": {
      "full": "<p>Returns a fixed list of size <code>n</code> containing a specified identical value.</p>",
      "summary": "<p>Returns a fixed list of size <code>n</code> containing a specified identical value.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.repeatN = curry2(function (value, n) {\n            return R.times(R.always(value), n);\n        });\n\n\n        // Function functions :-)\n        // ----------------------\n        //\n        // These functions make new functions out of old ones.",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "repeatN",
      "value": "curry2(function (value, n) {",
      "string": "R.repeatN"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "f",
        "description": "The function to partially apply `a` onto."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "a",
        "description": "The argument to partially apply onto `f`."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function."
      },
      {
        "type": "example",
        "string": "\nvar addThree = function(a, b, c) {\n  return a + b + c;\n};\nvar partialAdd = partially(add, 1);\npartialAdd(2, 3); //=> 6\n\n// partialAdd is invoked immediately, even though it expects three arguments. This is\n// because, unlike many functions here, the result of `partially` is not a curried\n// function.\npartialAdd(2); //≅ addThree(1, 2, undefined) => NaN"
      }
    ],
    "description": {
      "full": "<p>Returns a new function which partially applies a value to a given function, where the<br />function is a variadic function that cannot be curried.</p>",
      "summary": "<p>Returns a new function which partially applies a value to a given function, where the<br />function is a variadic function that cannot be curried.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function partially(f, a){\n            return function() {\n                return f.apply(this, concat([a], arguments));\n            };\n        }\n\n        // --------",
    "ctx": {
      "type": "function",
      "name": "partially",
      "string": "partially()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "f",
        "description": "A function."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "g",
        "description": "A function."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function that is the equivalent of `f(g(x))`."
      },
      {
        "type": "example",
        "string": "\nvar double = function(x) { return x * 2; };\nvar square = function(x) { return x * x; };\nvar squareThenDouble = internalCompose(double, square);\n\nsquareThenDouble(5); //≅ double(square(5)) => 50"
      }
    ],
    "description": {
      "full": "<p>Basic, right-associative composition function. Accepts two functions and returns the<br />composite function; this composite function represents the operation <code>var h = f(g(x))</code>,<br />where <code>f</code> is the first argument, <code>g</code> is the second argument, and <code>x</code> is whatever<br />argument(s) are passed to <code>h</code>.</p><p>This function&#39;s main use is to build the more general <code>compose</code> function, which accepts<br />any number of functions.</p>",
      "summary": "<p>Basic, right-associative composition function. Accepts two functions and returns the<br />composite function; this composite function represents the operation <code>var h = f(g(x))</code>,<br />where <code>f</code> is the first argument, <code>g</code> is the second argument, and <code>x</code> is whatever<br />argument(s) are passed to <code>h</code>.</p>",
      "body": "<p>This function&#39;s main use is to build the more general <code>compose</code> function, which accepts<br />any number of functions.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function internalCompose(f, g) {\n            return function() {\n                return f.call(this, g.apply(this, arguments));\n            };\n        }",
    "ctx": {
      "type": "function",
      "name": "internalCompose",
      "string": "internalCompose()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "...Function"
        ],
        "name": "functions",
        "description": "A variable number of functions."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function which represents the result of calling each of the input `functions`, passing the result of each function call to the next, from right to\nleft."
      },
      {
        "type": "example",
        "string": "\nvar triple = function(x) { return x * 2; };\nvar double = function(x) { return x * 2; };\nvar square = function(x) { return x * x; };\nvar squareThenDoubleThenTriple = ramda.compose(triple, double, square);\n\nsquareThenDoubleThenTriple(5); //≅ triple(double(square(5))) => 150"
      }
    ],
    "description": {
      "full": "<p>Creates a new function that runs each of the functions supplied as parameters in turn,<br />passing the return value of each function invocation to the next function invocation,<br />beginning with whatever arguments were passed to the initial invocation.</p><p>Note that <code>compose</code> is a right-associative function, which means the functions provided<br />will be invoked in order from right to left. In the example <code>var h = compose(f, g)</code>,<br />the function <code>h</code> is equivalent to <code>f( g(x) )</code>, where <code>x</code> represents the arguments<br />originally passed to <code>h</code>.</p>",
      "summary": "<p>Creates a new function that runs each of the functions supplied as parameters in turn,<br />passing the return value of each function invocation to the next function invocation,<br />beginning with whatever arguments were passed to the initial invocation.</p>",
      "body": "<p>Note that <code>compose</code> is a right-associative function, which means the functions provided<br />will be invoked in order from right to left. In the example <code>var h = compose(f, g)</code>,<br />the function <code>h</code> is equivalent to <code>f( g(x) )</code>, where <code>x</code> represents the arguments<br />originally passed to <code>h</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var compose = R.compose = function() {  // TODO: type check of arguments?\n            var length = arguments.length, func = arguments[--length];\n            if (!length) {\n                return partially(compose, func);\n            }\n            while (length--) {\n                func = internalCompose(arguments[length], func);\n            }\n            return func;\n        };",
    "ctx": {
      "type": "declaration",
      "name": "compose",
      "value": "R.compose = function() {  // TODO: type check of arguments?",
      "string": "compose"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "...Function"
        ],
        "name": "functions",
        "description": "A variable number of functions."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function which represents the result of calling each of the input `functions`, passing the result of each function call to the next, from right to\nleft."
      },
      {
        "type": "example",
        "string": "\nvar triple = function(x) { return x * 2; };\nvar double = function(x) { return x * 2; };\nvar square = function(x) { return x * x; };\nvar squareThenDoubleThenTriple = ramda.pipe(square, double, triple);\n\nsquareThenDoubleThenTriple(5); //≅ triple(double(square(5))) => 150"
      }
    ],
    "description": {
      "full": "<p>Creates a new function that runs each of the functions supplied as parameters in turn,<br />passing the return value of each function invocation to the next function invocation,<br />beginning with whatever arguments were passed to the initial invocation.</p><p><code>pipe</code> is the mirror version of <code>compose</code>. <code>pipe</code> is left-associative, which means that<br />each of the functions provided is executed in order from left to right.</p>",
      "summary": "<p>Creates a new function that runs each of the functions supplied as parameters in turn,<br />passing the return value of each function invocation to the next function invocation,<br />beginning with whatever arguments were passed to the initial invocation.</p>",
      "body": "<p><code>pipe</code> is the mirror version of <code>compose</code>. <code>pipe</code> is left-associative, which means that<br />each of the functions provided is executed in order from left to right.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.pipe = function() {  // TODO: type check of arguments?\n            if (arguments.length == 1) {\n                return partially (R.pipe, arguments[0]);\n            }\n            return compose.apply(this, _slice(arguments).reverse());\n        };\n        aliasFor(\"pipe\").is(\"sequence\");",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "pipe",
      "string": "R.pipe()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke with its first two parameters reversed."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The result of invoking `fn` with its first two parameters' order reversed."
      },
      {
        "type": "example",
        "string": "\nvar mergeThree = function(a, b, c) {\n  ([]).concat(a, b, c);\n};\nvar numbers = [1, 2, 3];\n\nmergeThree(numbers); //=> [1, 2, 3]\n\nramda.flip([1, 2, 3]); //=> [2, 1, 3]"
      }
    ],
    "description": {
      "full": "<p>Returns a new function much like the supplied one, except that the first two arguments&#39;<br />order is reversed.</p>",
      "summary": "<p>Returns a new function much like the supplied one, except that the first two arguments&#39;<br />order is reversed.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var flip = R.flip = function (fn) {\n            return function (a, b) {\n                return arguments.length < 2 ?\n                  function(b) { return fn.apply(this, [b, a].concat(_slice(arguments, 1))); } :\n                  fn.apply(this, [b, a].concat(_slice(arguments, 2)));\n            };\n        };",
    "ctx": {
      "type": "declaration",
      "name": "flip",
      "value": "R.flip = function (fn) {",
      "string": "flip"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke."
      },
      {
        "type": "param",
        "types": [
          "...*"
        ],
        "name": "[args]",
        "description": "Arguments to prepend to `fn` when the returned function is invoked."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. When invoked, it will call `fn` with `args` prepended to `fn`'s arguments list."
      },
      {
        "type": "example",
        "string": "\nvar multiply = function(a, b) { return a * b; };\nvar double = ramda.lPartial(multiply, 2);\n\ndouble(2); //=> 4\n\n\nvar greet = function(salutation, title, firstName, lastName) {\n  return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n};\nvar sayHello = ramda.lPartial(greet, 'Hello');\nvar sayHelloToMs = ramda.lPartial(sayHello, 'Ms.');\n\nsayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'"
      }
    ],
    "description": {
      "full": "<p>Accepts as its arguments a function and any number of values and returns a function that,<br />when invoked, calls the original function with all of the values prepended to the<br />original function&#39;s arguments list.</p>",
      "summary": "<p>Accepts as its arguments a function and any number of values and returns a function that,<br />when invoked, calls the original function with all of the values prepended to the<br />original function&#39;s arguments list.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.lPartial = function (fn",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "lPartial",
      "string": "R.lPartial()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>args</p>",
      "summary": "<p>args</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "{\n            var args = _slice(arguments, 1);\n            return arity(Math.max(fn.length - args.length, 0), function () {\n                return fn.apply(this, concat(args, arguments));\n            });\n        };\n        aliasFor(\"lPartial\").is(\"applyLeft\");"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to invoke."
      },
      {
        "type": "param",
        "types": [
          "...*"
        ],
        "name": "[args]",
        "description": "Arguments to append to `fn` when the returned function is invoked."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function wrapping `fn`. When invoked, it will call `fn` with `args` appended to `fn`'s arguments list."
      },
      {
        "type": "example",
        "string": "\nvar greet = function(salutation, title, firstName, lastName) {\n  return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n};\nvar greetMsJaneJones = ramda.rPartial(greet, 'Ms.', 'Jane', 'Jones');\n\ngreetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'"
      }
    ],
    "description": {
      "full": "<p>Accepts as its arguments a function and any number of values and returns a function that,<br />when invoked, calls the original function with all of the values appended to the original<br />function&#39;s arguments list.</p><p>Note that <code>rPartial</code> is the opposite of <code>lPartial</code>: <code>rPartial</code> fills <code>fn</code>&#39;s arguments<br />from the right to the left.</p>",
      "summary": "<p>Accepts as its arguments a function and any number of values and returns a function that,<br />when invoked, calls the original function with all of the values appended to the original<br />function&#39;s arguments list.</p>",
      "body": "<p>Note that <code>rPartial</code> is the opposite of <code>lPartial</code>: <code>rPartial</code> fills <code>fn</code>&#39;s arguments<br />from the right to the left.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.rPartial = function (fn) {\n            var args = _slice(arguments, 1);\n            return arity(Math.max(fn.length - args.length, 0), function() {\n                return fn.apply(this, concat(arguments, args));\n            });\n        };\n        aliasFor(\"rPartial\").is(\"applyRight\");",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "rPartial",
      "string": "R.rPartial()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to be wrapped by `memoize`."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "Returns a memoized version of `fn`."
      },
      {
        "type": "example",
        "string": "\nvar numberOfCalls = 0;\nvar tracedAdd = function(a, b) {\n  numberOfCalls += 1;\n  return a + b;\n};\nvar memoTrackedAdd = ramda.memoize(trackedAdd);\n\nmemoAdd(1, 2); //=> 3 (numberOfCalls => 1)\nmemoAdd(1, 2); //=> 3 (numberOfCalls => 1)\nmemoAdd(2, 3); //=> 5 (numberOfCalls => 2)\n\n// Note that argument order matters\nmemoAdd(2, 1); //=> 3 (numberOfCalls => 3)"
      }
    ],
    "description": {
      "full": "<p>Creates a new function that, when invoked, caches the result of calling <code>fn</code> for a given<br />argument set and returns the result. Subsequent calls to the memoized <code>fn</code> with the same<br />argument set will not result in an additional call to <code>fn</code>; instead, the cached result<br />for that set of arguments will be returned.</p><p>Note that this version of <code>memoize</code> effectively handles only string and number<br />parameters.</p>",
      "summary": "<p>Creates a new function that, when invoked, caches the result of calling <code>fn</code> for a given<br />argument set and returns the result. Subsequent calls to the memoized <code>fn</code> with the same<br />argument set will not result in an additional call to <code>fn</code>; instead, the cached result<br />for that set of arguments will be returned.</p>",
      "body": "<p>Note that this version of <code>memoize</code> effectively handles only string and number<br />parameters.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.memoize = function (fn) {\n            var cache = {};\n            return function () {\n                var position = foldl(function (cache, arg) {\n                        return cache[arg] || (cache[arg] = {});\n                    }, cache,\n                    _slice(arguments, 0, arguments.length - 1));\n                var arg = arguments[arguments.length - 1];\n                return (position[arg] || (position[arg] = fn.apply(this, arguments)));\n            };\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "memoize",
      "string": "R.memoize()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap in a call-only-once wrapper."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "The wrapped function."
      },
      {
        "type": "example",
        "string": "\nvar alertOnce = ramda.once(alert);\nalertOnce('Hello!'); // Alerts 'Hello!'\nalertOnce('Nothing'); // Doesn't alert\nalertOnce('Again'); // Doesn't alert"
      }
    ],
    "description": {
      "full": "<p>Accepts a function <code>fn</code> and returns a function that guards invocation of <code>fn</code> such that<br /><code>fn</code> can only ever be called once, no matter how many times the returned function is<br />invoked.</p>",
      "summary": "<p>Accepts a function <code>fn</code> and returns a function that guards invocation of <code>fn</code> such that<br /><code>fn</code> can only ever be called once, no matter how many times the returned function is<br />invoked.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.once = function (fn) {\n            var called = false, result;\n            return function () {\n                if (called) {\n                    return result;\n                }\n                called = true;\n                result = fn.apply(this, arguments);\n                return result;\n            };\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "once",
      "string": "R.once()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to wrap."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "wrapper",
        "description": "The wrapper function."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "The wrapped function."
      },
      {
        "type": "example",
        "string": "\nTODO"
      }
    ],
    "description": {
      "full": "<p>Wrap a function inside another to allow you to make adjustments to the parameters, or do<br />other processing either before the internal function is called or with its results.</p>",
      "summary": "<p>Wrap a function inside another to allow you to make adjustments to the parameters, or do<br />other processing either before the internal function is called or with its results.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.wrap = function(fn, wrapper) {\n            return function() {\n                return wrapper.apply(this, concat([fn], arguments));\n            };\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "wrap",
      "string": "R.wrap()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Function"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "Fn",
        "description": "The constructor function to wrap."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A wrapped, curried constructor function."
      },
      {
        "type": "example",
        "string": "\n// Constructor function\nvar Widget = function(config) {\n  // ...\n};\nWidget.prototype = {\n  // ...\n};\nmap(construct(Widget), allConfigs); //=> a list of Widgets"
      }
    ],
    "description": {
      "full": "<p>Wraps a constructor function inside a curried function that can be called with the same<br />arguments and returns the same type.</p>",
      "summary": "<p>Wraps a constructor function inside a curried function that can be called with the same<br />arguments and returns the same type.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.construct = function (Fn) {\n            var f = function () {\n                var obj = new Fn();\n                Fn.apply(obj, arguments);\n                return obj;\n            };\n            return Fn.length > 1 ? curry(nAry(Fn.length, f)) : f;\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "construct",
      "string": "R.construct()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "after",
        "description": "A function. `after` will be invoked with the return values of `fn1` and `fn2` as its arguments."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn1",
        "description": "A function. It will be invoked with the arguments passed to the returned function. Afterward, its resulting value will be passed to `after` as its first\nargument."
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn2",
        "description": "A function. It will be invoked with the arguments passed to the returned function. Afterward, its resulting value will be passed to `after` as its second\nargument."
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "A new function."
      },
      {
        "type": "example",
        "string": "\nvar add = function(a, b) { return a + b; };\nvar multiply = function(a, b) { return a * b; };\nvar subtract = function(a, b) { return a - b; };\n\nramda.fork(multiply, add, subtract)(1, 2);\n//≅ multiply( add(1, 2), subtract(1, 2) );\n//=> -3"
      }
    ],
    "description": {
      "full": "<p>Accepts three functions and returns a new function. When invoked, this new function will<br />invoke the first function, <code>after</code>, passing as its arguments the results of invoking the<br />second and third functions with whatever arguments are passed to the new function.</p><p>For example, a function produced by <code>fork</code> is equivalent to:</p><pre><code class=\"lang-javascript\">  var h = ramda.fork(e, f, g);\n  h(1, 2); //≅ e( f(1, 2), g(1, 2) )\n</code></pre>\n",
      "summary": "<p>Accepts three functions and returns a new function. When invoked, this new function will<br />invoke the first function, <code>after</code>, passing as its arguments the results of invoking the<br />second and third functions with whatever arguments are passed to the new function.</p>",
      "body": "<p>For example, a function produced by <code>fork</code> is equivalent to:</p><pre><code class=\"lang-javascript\">  var h = ramda.fork(e, f, g);\n  h(1, 2); //≅ e( f(1, 2), g(1, 2) )\n</code></pre>\n"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.fork = function (after) {\n            var fns = _slice(arguments, 1);\n            return function () {\n                var args = arguments;\n                return after.apply(this, map(function (fn) {\n                    return fn.apply(this, args);\n                }, fns));\n            };\n        };\n\n        // List Functions\n        // --------------\n        //\n        // These functions operate on logical lists, here plain arrays.  Almost all of these are curried, and the list\n        // parameter comes last, so you can create a new function by supplying the preceding arguments, leaving the\n        // list parameter off.  For instance:\n        //\n        //     // skip third parameter\n        //     var checkAllPredicates = reduce(andFn, alwaysTrue);\n        //     // ... given suitable definitions of odd, lt20, gt5\n        //     var test = checkAllPredicates([odd, lt20, gt5]);\n        //     // test(7) => true, test(9) => true, test(10) => false,\n        //     // test(3) => false, test(21) => false,\n\n        // --------",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "fork",
      "string": "R.fork()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "alias",
        "string": "reduce"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The iterator function. Receives two values, the accumulator and the current element from the array."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "acc",
        "description": "The accumulator value."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The final, accumulated value."
      },
      {
        "type": "example",
        "string": "\nvar numbers = [1, 2, 3];\nvar add = function(a, b) {\n  return a + b;\n};\n\nfoldl(numbers, add, 10); //=> 16"
      }
    ],
    "description": {
      "full": "<p>Returns a single item by iterating through the list, successively calling the iterator<br />function and passing it an accumulator value and the current value from the array, and<br />then passing the result to the next call.</p><p>The iterator function receives two values: <em>(acc, value)</em></p><p>Note: <code>ramda.foldl</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>",
      "summary": "<p>Returns a single item by iterating through the list, successively calling the iterator<br />function and passing it an accumulator value and the current value from the array, and<br />then passing the result to the next call.</p>",
      "body": "<p>The iterator function receives two values: <em>(acc, value)</em></p><p>Note: <code>ramda.foldl</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var foldl = R.foldl =  curry3(function(fn, acc, list) {\n            if (hasMethod('foldl', list)) {\n                return list.foldl(fn, acc);\n            }\n            var idx = -1, len = list.length;\n            while (++idx < len) {\n                acc = fn(acc, list[idx]);\n            }\n            return acc;\n        });\n        aliasFor(\"foldl\").is(\"reduce\");",
    "ctx": {
      "type": "declaration",
      "name": "foldl",
      "value": "R.foldl =  curry3(function(fn, acc, list) {",
      "string": "foldl"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The iterator function. Receives four values: the accumulator, the current element from `list`, that element's index, and the entire `list` itself."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "acc",
        "description": "The accumulator value."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The final, accumulated value."
      },
      {
        "type": "example",
        "string": "\nvar letters = ['a', 'b', 'c'];\nvar objectify = function(accObject, elem, idx, list) {\n  return accObject[elem] = idx;\n};\n\nfoldl.idx(letters, objectify, {}); //=> { 'a': 0, 'b': 1, 'c': 2 }"
      }
    ],
    "description": {
      "full": "<p>Like <code>foldl</code>, but passes additional parameters to the predicate function.</p><p>The iterator function receives four values: <em>(acc, value, index, list)</em></p><p>Note: <code>ramda.foldl.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.filter</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>",
      "summary": "<p>Like <code>foldl</code>, but passes additional parameters to the predicate function.</p>",
      "body": "<p>The iterator function receives four values: <em>(acc, value, index, list)</em></p><p>Note: <code>ramda.foldl.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.filter</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.foldl.idx = curry3(function(fn, acc, list) {\n            if (hasMethod('foldl', list)) {\n                return list.foldl(fn, acc);\n            }\n            var idx = -1, len = list.length;\n            while (++idx < len) {\n                acc = fn(acc, list[idx], idx, list);\n            }\n            return acc;\n        });"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "alias",
        "string": "reduceRight"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The iterator function. Receives two values, the accumulator and the current element from the array."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "acc",
        "description": "The accumulator value."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The final, accumulated value."
      },
      {
        "type": "example",
        "string": "\nvar pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\nvar flattenPairs = function(acc, pair) {\n  return acc.concat(pair);\n};\n\nfoldr(numbers, flattenPairs, []); //=> [ 'c', 3, 'b', 2, 'a', 1 ]"
      }
    ],
    "description": {
      "full": "<p>Returns a single item by iterating through the list, successively calling the iterator<br />function and passing it an accumulator value and the current value from the array, and<br />then passing the result to the next call.</p><p>Similar to <code>foldl</code>, except moves through the input list from the right to the left.</p><p>The iterator function receives two values: <em>(acc, value)</em></p><p>Note: <code>ramda.foldr</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>",
      "summary": "<p>Returns a single item by iterating through the list, successively calling the iterator<br />function and passing it an accumulator value and the current value from the array, and<br />then passing the result to the next call.</p>",
      "body": "<p>Similar to <code>foldl</code>, except moves through the input list from the right to the left.</p><p>The iterator function receives two values: <em>(acc, value)</em></p><p>Note: <code>ramda.foldr</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var foldr = R.foldr = curry3(function(fn, acc, list) {\n            if (hasMethod('foldr', list)) {\n                return list.foldr(fn, acc);\n            }\n            var idx = list.length;\n            while (idx--) {\n                acc = fn(acc, list[idx]);\n            }\n            return acc;\n        });\n        aliasFor(\"foldr\").is(\"reduceRight\");",
    "ctx": {
      "type": "declaration",
      "name": "foldr",
      "value": "R.foldr = curry3(function(fn, acc, list) {",
      "string": "foldr"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The iterator function. Receives four values: the accumulator, the current element from `list`, that element's index, and the entire `list` itself."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "acc",
        "description": "The accumulator value."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to iterate over."
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "The final, accumulated value."
      },
      {
        "type": "example",
        "string": "\nvar letters = ['a', 'b', 'c'];\nvar objectify = function(accObject, elem, idx, list) {\n  return accObject[elem] = idx;\n};\n\nfoldr.idx(letters, objectify, {}); //=> { 'c': 2, 'b': 1, 'a': 0 }"
      }
    ],
    "description": {
      "full": "<p>Like <code>foldr</code>, but passes additional parameters to the predicate function. Moves through<br />the input list from the right to the left.</p><p>The iterator function receives four values: <em>(acc, value, index, list)</em>.</p><p>Note: <code>ramda.foldr.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.filter</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>",
      "summary": "<p>Like <code>foldr</code>, but passes additional parameters to the predicate function. Moves through<br />the input list from the right to the left.</p>",
      "body": "<p>The iterator function receives four values: <em>(acc, value, index, list)</em>.</p><p>Note: <code>ramda.foldr.idx</code> does not skip deleted or unassigned indices (sparse arrays),<br />unlike the native <code>Array.prototype.filter</code> method. For more details on this behavior,<br />see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.foldr.idx = curry3(function (fn, acc, list) {\n            if (hasMethod('foldr', list)) {\n                return list.foldr(fn, acc);\n            }\n            var idx = list.length;\n            while (idx--) {\n                acc = fn(acc, list[idx], idx, list);\n            }\n            return acc;\n        });"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The iterator function. receives one argument, `seed`, and returns either false to quit iteration or an array of length two to proceed. The element at index\n0 of this array will be added to the resulting array, and the element at index 1 will be\npassed to the next call to `fn`."
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "seed",
        "description": "The seed value."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The final list."
      },
      {
        "type": "example",
        "string": "TODO"
      }
    ],
    "description": {
      "full": "<p>Builds a list from a seed value. Accepts an iterator function, which returns either false<br />to stop iteration or an array of length 2 containing the value to add to the resulting<br />list and the seed to be used in the next call to the iterator function.</p><p>The iterator function receives one argument: <em>(seed)</em>.</p>",
      "summary": "<p>Builds a list from a seed value. Accepts an iterator function, which returns either false<br />to stop iteration or an array of length 2 containing the value to add to the resulting<br />list and the seed to be used in the next call to the iterator function.</p>",
      "body": "<p>The iterator function receives one argument: <em>(seed)</em>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.unfoldr = curry2(function (fn, seed) {\n            var pair = fn(seed);\n            var result = [];\n            while (pair && pair.length) {\n                result.push(pair[0]);\n                pair = fn(pair[1]);\n            }\n            return result;\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "unfoldr",
      "value": "curry2(function (fn, seed) {",
      "string": "R.unfoldr"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to be called on every element of the input `list`."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to be iterated over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new list."
      },
      {
        "type": "example",
        "string": "\nvar double = function(x) {\n  return x * 2;\n};\n\nramda.map(double, [1, 2, 3]); //=> [2, 4, 6]"
      }
    ],
    "description": {
      "full": "<p>Returns a new list, constructed by applying the supplied function to every element of the<br />supplied list.</p><p>Note: <code>ramda.map</code> does not skip deleted or unassigned indices (sparse arrays), unlike the<br />native <code>Array.prototype.map</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description</a></p>",
      "summary": "<p>Returns a new list, constructed by applying the supplied function to every element of the<br />supplied list.</p>",
      "body": "<p>Note: <code>ramda.map</code> does not skip deleted or unassigned indices (sparse arrays), unlike the<br />native <code>Array.prototype.map</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function map(fn, list) {\n            if (hasMethod('map', list)) {\n                return list.map(fn);\n            }\n            var idx = -1, len = list.length, result = new Array(len);\n            while (++idx < len) {\n                result[idx] = fn(list[idx]);\n            }\n            return result;\n        }\n        R.map = curry2(map);",
    "ctx": {
      "type": "function",
      "name": "map",
      "string": "map()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function to be called on every element of the input `list`."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The list to be iterated over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new list."
      },
      {
        "type": "example",
        "string": "\nvar squareEnds = function(elt, idx, list) {\n  if (idx === 0 || idx === list.length - 1) {\n    return elt * elt;\n  }\n  return elt;\n};\n\nramda.map.idx(squareEnds, [8, 6, 7, 5, 3, 0, 9];\n//=> [64, 6, 7, 5, 3, 0, 81]"
      }
    ],
    "description": {
      "full": "<p>Like <code>map</code>, but but passes additional parameters to the predicate function.</p><p><code>fn</code> receives three arguments: <em>(value, index, list)</em>.</p><p>Note: <code>ramda.map.idx</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.map</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description</a></p>",
      "summary": "<p>Like <code>map</code>, but but passes additional parameters to the predicate function.</p>",
      "body": "<p><code>fn</code> receives three arguments: <em>(value, index, list)</em>.</p><p>Note: <code>ramda.map.idx</code> does not skip deleted or unassigned indices (sparse arrays), unlike<br />the native <code>Array.prototype.map</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.map.idx = curry2(function(fn, list) {\n            if (hasMethod('map', list)) {\n                return list.map(fn);\n            }\n            var idx = -1, len = list.length, result = new Array(len);\n            while (++idx < len) {\n                result[idx] = fn(list[idx], idx, list);\n            }\n            return result;\n        });"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "fn",
        "description": "A function called for each property in `obj`. Its return value will become a new property on the return object."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "The object to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "A new object with the same keys as `obj` and values that are the result of running each property through `fn`."
      },
      {
        "type": "example",
        "string": "\nvar values = { x: 1, y: 2, z: 3 };\nvar double = function(num) {\n  return num * 2;\n};\n\nramda.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }"
      }
    ],
    "description": {
      "full": "<p>Map, but for objects. Creates an object with the same keys as <code>obj</code> and values<br />generated by running each property of <code>obj</code> through <code>fn</code>. <code>fn</code> is passed one argument:<br /><em>(value)</em>.</p>",
      "summary": "<p>Map, but for objects. Creates an object with the same keys as <code>obj</code> and values<br />generated by running each property of <code>obj</code> through <code>fn</code>. <code>fn</code> is passed one argument:<br /><em>(value)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// TODO: consider mapObj.key in parallel with mapObj.idx.  Also consider folding together with `map` implementation.\n        R.mapObj = curry2(function (fn, obj) {\n            return foldl(function (acc, key) {\n                acc[key] = fn(obj[key]);\n                return acc;\n            }, {}, keys(obj));\n        });"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "fn",
        "description": "A function called for each property in `obj`. Its return value will become a new property on the return object."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "The object to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "A new object with the same keys as `obj` and values that are the result of running each property through `fn`."
      },
      {
        "type": "example",
        "string": "\nvar values = { x: 1, y: 2, z: 3 };\nvar double = function(num, key, obj) {\n  return key + num;\n};\n\nramda.mapObj(double, values); //=> { x: 'x2', y: 'y4', z: 'z6' }"
      }
    ],
    "description": {
      "full": "<p>Like <code>mapObj</code>, but but passes additional arguments to the predicate function. The<br />predicate function is passed three arguments: <em>(value, key, obj)</em>.</p>",
      "summary": "<p>Like <code>mapObj</code>, but but passes additional arguments to the predicate function. The<br />predicate function is passed three arguments: <em>(value, key, obj)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.mapObj.idx = function (fn, obj) {\n            function _mapObjIdx(obj) {\n                return foldl(function (acc, key) {\n                    acc[key] = fn(obj[key], key, obj);\n                    return acc;\n                }, {}, keys(obj));\n            }\n            return arguments.length < 2 ? _mapObjIdx : _mapObjIdx(obj);\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R.mapObj",
      "name": "idx",
      "string": "R.mapObj.idx()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arr",
        "description": "The array to inspect."
      },
      {
        "type": "return",
        "types": [
          "number"
        ],
        "description": "The size of the array."
      },
      {
        "type": "example",
        "string": "\nramda.size([]); //=> 0\nramda.size([1, 2, 3]); //=> 3"
      }
    ],
    "description": {
      "full": "<p>Returns the number of elements in the array by returning <code>arr.length</code>.</p>",
      "summary": "<p>Returns the number of elements in the array by returning <code>arr.length</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.size = function (arr) {\n            return arr.length;\n        };",
    "ctx": {
      "type": "method",
      "receiver": "R",
      "name": "size",
      "string": "R.size()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new filtered array."
      },
      {
        "type": "example",
        "string": "\nvar isEven = function(n) {\n    return n % 2 === 0;\n};\nvar evens = ramda.filter(isEven, [1, 2, 3, 4]); // => [2, 4]"
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing only those items that match a given predicate function.<br />The predicate function is passed one argument: <em>(value)</em>.</p><p>Note that <code>ramda.filter</code> does not skip deleted or unassigned indices, unlike the native<br /><code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description</a></p>",
      "summary": "<p>Returns a new list containing only those items that match a given predicate function.<br />The predicate function is passed one argument: <em>(value)</em>.</p>",
      "body": "<p>Note that <code>ramda.filter</code> does not skip deleted or unassigned indices, unlike the native<br /><code>Array.prototype.filter</code> method. For more details on this behavior, see:<br /><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var filter = function(fn, list) {\n            if (hasMethod('filter', list)) {\n                return list.filter(fn);\n            }\n            var idx = -1, len = list.length, result = [];\n            while (++idx < len) {\n                if (fn(list[idx])) {\n                    result.push(list[idx]);\n                }\n            }\n            return result;\n        };\n\n        R.filter = curry2(filter);",
    "ctx": {
      "type": "function",
      "name": "filter",
      "string": "filter()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new filtered array."
      },
      {
        "type": "example",
        "string": "\nvar lastTwo = function(val, idx, list) {\n    return list.length - idx <= 2;\n};\nramda.filter.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [0, 9]"
      }
    ],
    "description": {
      "full": "<p>Like <code>filter</code>, but passes additional parameters to the predicate function. The predicate<br />function is passed three arguments: <em>(value, index, list)</em>.</p>",
      "summary": "<p>Like <code>filter</code>, but passes additional parameters to the predicate function. The predicate<br />function is passed three arguments: <em>(value, index, list)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var filterIdx = function(fn, list) {\n            if (hasMethod('filter', list)) {\n                return list.filter(fn);\n            }\n            var idx = -1, len = list.length, result = [];\n            while (++idx < len) {\n                if (fn(list[idx], idx, list)) {\n                    result.push(list[idx]);\n                }\n            }\n            return result;\n        };\n\n        R.filter.idx = curry2(filterIdx);",
    "ctx": {
      "type": "function",
      "name": "filterIdx",
      "string": "filterIdx()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new filtered array."
      },
      {
        "type": "example",
        "string": "\nvar isEven = function(n) {\n    return n % 2 === 0;\n};\nvar odds = ramda.reject(isOdd, [1, 2, 3, 4]); // => [2, 4]"
      }
    ],
    "description": {
      "full": "<p>Similar to <code>filter</code>, except that it keeps only values for which the given predicate<br />function returns falsy. The predicate function is passed one argument: <em>(value)</em>.</p>",
      "summary": "<p>Similar to <code>filter</code>, except that it keeps only values for which the given predicate<br />function returns falsy. The predicate function is passed one argument: <em>(value)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var reject = function(fn, list) {\n            return filter(not(fn), list);\n        };\n\n        R.reject = curry2(reject);",
    "ctx": {
      "type": "function",
      "name": "reject",
      "string": "reject()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The new filtered array."
      },
      {
        "type": "example",
        "string": "\nvar lastTwo = function(val, idx, list) {\n    return list.length - idx <= 2;\n};\n\nreject.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [8, 6, 7, 5, 3]"
      }
    ],
    "description": {
      "full": "<p>Like <code>reject</code>, but passes additional parameters to the predicate function. The predicate<br />function is passed three arguments: <em>(value, index, list)</em>.</p>",
      "summary": "<p>Like <code>reject</code>, but passes additional parameters to the predicate function. The predicate<br />function is passed three arguments: <em>(value, index, list)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.reject.idx = curry2(function(fn, list) {\n            return filterIdx(not(fn), list);\n        });"
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array."
      },
      {
        "type": "example",
        "string": "\nvar isNotFour = function(x) {\n  return !(x === 4);\n};\n\ntakeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]"
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing the first <code>n</code> elements of a given list, passing each value<br />to the supplied predicate function, and terminating when the predicate function returns<br /><code>false</code>. Excludes the element that caused the predicate function to fail. The predicate<br />function is passed one argument: <em>(value)</em>.</p>",
      "summary": "<p>Returns a new list containing the first <code>n</code> elements of a given list, passing each value<br />to the supplied predicate function, and terminating when the predicate function returns<br /><code>false</code>. Excludes the element that caused the predicate function to fail. The predicate<br />function is passed one argument: <em>(value)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.takeWhile = curry2(function(fn, list) {\n            if (hasMethod('takeWhile', list)) {\n                return list.takeWhile(fn);\n            }\n            var idx = -1, len = list.length;\n            while (++idx < len && fn(list[idx])) {}\n            return _slice(list, 0, idx);\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "takeWhile",
      "value": "curry2(function(fn, list) {",
      "string": "R.takeWhile"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "The number of elements to return."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The array to query."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array containing the first elements of `list`."
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing the first <code>n</code> elements of the given list.  If<br /><code>n &gt; * list.length</code>, returns a list of <code>list.length</code> elements.</p>",
      "summary": "<p>Returns a new list containing the first <code>n</code> elements of the given list.  If<br /><code>n &gt; * list.length</code>, returns a list of <code>list.length</code> elements.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.take = curry2(function(n, list) {\n            if (hasMethod('take', list)) {\n                return list.take(n);\n            }\n            var ls = clone(list);\n            ls.length = Math.min(n, list.length);\n            return ls;\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "take",
      "value": "curry2(function(n, list) {",
      "string": "R.take"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "The function called per iteration."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The collection to iterate over."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "A new array."
      },
      {
        "type": "example",
        "string": "\nvar isNotTwo = function(x) {\n  return !(x === 2);\n};\n\nskipUntil(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]"
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing the last <code>n</code> elements of a given list, passing each value<br />to the supplied predicate function, beginning when the predicate function returns<br /><code>true</code>. Excludes the element that caused the predicate function to fail. The predicate<br />function is passed one argument: <em>(value)</em>.</p>",
      "summary": "<p>Returns a new list containing the last <code>n</code> elements of a given list, passing each value<br />to the supplied predicate function, beginning when the predicate function returns<br /><code>true</code>. Excludes the element that caused the predicate function to fail. The predicate<br />function is passed one argument: <em>(value)</em>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.skipUntil = curry2(function (fn, list) {\n            var idx = -1, len = list.length;\n            while (++idx < len && !fn(list[idx])) {}\n            return _slice(list, idx);\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "skipUntil",
      "value": "curry2(function (fn, list) {",
      "string": "R.skipUntil"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "List"
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "The number of elements of `list` to skip."
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "list",
        "description": "The array to consider."
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "The last `n` elements of `list`."
      }
    ],
    "description": {
      "full": "<p>Returns a new list containing all but the first <code>n</code> elements of the given <code>list</code>.</p>",
      "summary": "<p>Returns a new list containing all but the first <code>n</code> elements of the given <code>list</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.skip = curry2(function(n, list) {\n            if (hasMethod('skip', list)) {\n                return list.skip(n);\n            }\n            return _slice(list, n);\n        });\n        aliasFor('skip').is('drop');",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "skip",
      "value": "curry2(function(n, list) {",
      "string": "R.skip"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the first element of the list which matches the predicate, or `undefined` if no element matches.\n        R.find = function (fn, list) {\n            function _find(list) {\n                var idx = -1;\n                var len = list.length;\n                while (++idx < len) {\n                    if (fn(list[idx])) {\n                        return list[idx];\n                    }\n                }\n                return undef;\n            }\n            return arguments.length < 2 ? _find : _find(list);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the index of first element of the list which matches the predicate, or `undefined` if no element matches.\n        R.findIndex = curry2(function(fn, list) {\n            var idx = -1;\n            var len = list.length;\n            while (++idx < len) {\n                if (fn(list[idx])) {\n                    return idx;\n                }\n            }\n            return -1;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the last element of the list which matches the predicate, or `undefined` if no element matches.\n        R.findLast = curry2(function(fn, list) {\n            var idx = list.length;\n            while (--idx) {\n                if (fn(list[idx])) {\n                    return list[idx];\n                }\n            }\n            return undef;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the index of last element of the list which matches the predicate, or `undefined` if no element matches.\n        R.findLastIndex = curry2(function(fn, list) {\n            var idx = list.length;\n            while (--idx) {\n                if (fn(list[idx])) {\n                    return idx;\n                }\n            }\n            return -1;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns `true` if all elements of the list match the predicate, `false` if there are any that don't.\n        var all = function(fn, list) {\n            var i = -1;\n            while (++i < list.length) {\n                if (!fn(list[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        R.all = curry2(all);\n        aliasFor(\"all\").is(\"every\");"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns `true` if any elements of the list match the predicate, `false` if none do.\n        var any = function (fn, list) {\n            var i = -1;\n            while (++i < list.length) {\n                if (fn(list[i])) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        R.any = curry2(any);\n        aliasFor(\"any\").is(\"some\");"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Internal implementations of indexOf and lastIndexOf\n\n        // Return the position of the first occurrence of an item in an array,\n        // or -1 if the item is not included in the array.\n        var indexOf = function(array, item, from) {\n            var i = 0, length = array.length;\n            if (typeof from == 'number') {\n                i = from < 0 ? Math.max(0, length + from) : from;\n            }\n            for (; i < length; i++) {\n                if (array[i] === item) return i;\n            }\n            return -1;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var lastIndexOf = function(array, item, from) {\n            var idx = array.length;\n            if (typeof from == 'number') {\n                idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n            }\n            while (--idx >= 0) {\n                if (array[idx] === item) return idx;\n            }\n            return -1;\n        };",
    "ctx": {
      "type": "function",
      "name": "lastIndexOf",
      "string": "lastIndexOf()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the first zero-indexed position of an object in a flat list\n        R.indexOf = curry2(function _indexOf(target, list) {\n            return indexOf(list, target);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.indexOf.from = curry3(function indexOfFrom(target, fromIdx, list) {\n            return indexOf(list, target, fromIdx);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the last zero-indexed position of an object in a flat list\n        R.lastIndexOf = curry2(function _lastIndexOf(target, list) {\n            return lastIndexOf(list, target);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.lastIndexOf.from = curry3(function lastIndexOfFrom(target, fromIdx, list) {\n            return lastIndexOf(list, target, fromIdx);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns `true` if the list contains the sought element, `false` if it does not.  Equality is strict here,\n        // meaning reference equality for objects and non-coercing equality for primitives.\n        function contains(a, list) {\n            return indexOf(list, a) > -1;\n        }\n        R.contains = curry2(contains);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns `true` if the list contains the sought element, `false` if it does not, based upon the value\n        // returned by applying the supplied predicated to two list elements.  Equality is strict here, meaning\n        // reference equality for objects and non-coercing equality for primitives.  Probably inefficient.\n        var containsWith = function (pred, x, list) {\n            var idx = -1, len = list.length;\n            while (++idx < len) {\n                if (pred(x, list[idx])) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        R.containsWith = curry3(containsWith);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a new list containing only one copy of each element in the original list.  Equality is strict here,\n        // meaning reference equality for objects and non-coercing equality for primitives.\n\n        var uniq = R.uniq = function uniq(list) {\n            var idx = -1, len = list.length;\n            var result = [], item;\n            while (++idx < len) {\n                item = list[idx];\n                if (!contains(item, result)) {\n                    result.push(item);\n                }\n            }\n            return result;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// returns `true` if all of the elements in the `list` are unique.\n        R.isSet = function (list) {\n            var len = list.length;\n            var i = -1;\n            while (++i < len) {\n                if (indexOf(list, list[i], i+1) >= 0) {\n                    return false;\n                }\n            }\n            return true;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a new list containing only one copy of each element in the original list, based upon the value\n        // returned by applying the supplied predicate to two list elements.   Equality is strict here,  meaning\n        // reference equality for objects and non-coercing equality for primitives.\n        var uniqWith = R.uniqWith = curry2(function(pred, list) {\n            var idx = -1, len = list.length;\n            var result = [], item;\n            while (++idx < len) {\n                item = list[idx];\n                if (!containsWith(pred, item, result)) {\n                    result.push(item);\n                }\n            }\n            return result;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a new list by plucking the same named property off all objects in the list supplied.\n        var pluck = R.pluck = curry2(function(p, list) {\n            return map(prop(p), list);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a list that contains a flattened version of the supplied list.  For example:\n        //\n        //     flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n        //     // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        var flatten = R.flatten = function(list) {\n            var output = [], idx = 0, value;\n            for (var i = 0, length = list.length; i < length; i++) {\n              value = list[i];\n              if (isArray(value)) {\n                //flatten current level of array or arguments object\n                value = flatten(value);\n                var j = 0, len = value.length;\n                output.length += len;\n                while (j < len) {\n                  output[idx++] = value[j++];\n                }\n              } else {\n                output[idx++] = value;\n              }\n            }\n            return output;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Creates a new list out of the two supplied by applying the function to each equally-positioned pair in the\n        // lists.  For example,\n        //\n        //     zipWith(f, [1, 2, 3], ['a', 'b', 'c'])\n        //     //    => [f(1, 'a'), f(2, 'b'), f(3, 'c')];\n        //\n        // Note that the output list will only be as long as the length of the shorter input list.\n        R.zipWith = curry3(function(fn, a, b) {\n            var rv = [], i = -1, len = Math.min(a.length, b.length);\n            while (++i < len) {\n                rv[i] = fn(a[i], b[i]);\n            }\n            return rv;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Creates a new list out of the two supplied by yielding the pair of each equally-positioned pair in the\n        // lists.  For example,\n        //\n        //     zip([1, 2, 3], ['a', 'b', 'c'])\n        //     //    => [[1, 'a'], [2, 'b'], [3, 'c']];\n        R.zip = curry2(function(a, b) { // = zipWith(prepend);\n            var rv = [];\n            var i = -1;\n            var len = Math.min(a.length, b.length);\n            while (++i < len) {\n                rv[i] = [a[i], b[i]];\n            }\n            return rv;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Creates a new list out of the two supplied by applying the function to each possible pair in the lists.\n        //  For example,\n        //\n        //     xProdWith(f, [1, 2], ['a', 'b'])\n        //     //    => [f(1, 'a'), f(1, 'b'), f(2, 'a'), f(2, 'b')];\n        R.xprodWith = curry3(function (fn, a, b) {\n            if (isEmpty(a) || isEmpty(b)) {\n                return [];\n            }\n            var i = -1, ilen = a.length, j, jlen = b.length, result = []; // better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n            while (++i < ilen) {\n                j = -1;\n                while (++j < jlen) {\n                    result.push(fn(a[i], b[j]));\n                }\n            }\n            return result;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Creates a new list out of the two supplied by yielding the pair of each possible pair in the lists.\n        // For example,\n        //\n        //     xProd([1, 2], ['a', 'b'])\n        //     //    => [[1, 'a'], [1, 'b')], [2, 'a'], [2, 'b']];\n        R.xprod = curry2(function (a, b) { // = xprodWith(prepend); (takes about 3 times as long...)\n            if (isEmpty(a) || isEmpty(b)) {\n                return [];\n            }\n            var i = -1;\n            var ilen = a.length;\n            var j;\n            var jlen = b.length;\n            var result = []; // better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n            while (++i < ilen) {\n                j = -1;\n                while (++j < jlen) {\n                    result.push([a[i], b[j]]);\n                }\n            }\n            return result;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a new list with the same elements as the original list, just in the reverse order.\n        R.reverse = function (list) {\n            return clone(list || []).reverse();\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// // Returns a list of numbers from `from` (inclusive) to `to` (exclusive).\n        // For example,\n        //\n        //     range(1, 5) // => [1, 2, 3, 4]\n        //     range(50, 53) // => [50, 51, 52]\n        R.range = curry2(function (from, to) {\n            if (from >= to) {\n                return [];\n            }\n            var idx = 0, result = new Array(Math.floor(to) - Math.ceil(from));\n            for (; from < to; idx++, from++) {\n                result[idx] = from;\n            }\n            return result;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the elements of the list as a string joined by a separator.\n        R.join = invoker(\"join\", Array.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns the sublist of a list starting with the first index and\n        // ending before the second one.\n        R.slice = invoker(\"slice\", Array.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.slice.from = flip(R.slice)(undef);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Removes the sub-list of `list` starting at index `start` and containing\n        // `count` elements.  _Note that this is not destructive_: it returns a\n        // copy of the list with the changes.\n        // <small>No lists have been harmed in the application of this function.</small>\n        R.remove = curry3(function(start, count, list) {\n            return concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Inserts the supplied element into the list, at index `index`.  _Note\n        // that this is not destructive_: it returns a copy of the list with the changes.\n        // <small>No lists have been harmed in the application of this function.</small>\n        R.insert = curry3(function(index, elt, list) {\n            index = index < list.length && index >= 0 ? index : list.length;\n            return concat(append(elt, _slice(list, 0, index)), _slice(list, index));\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Inserts the sub-list into the list, at index `index`.  _Note  that this\n        // is not destructive_: it returns a copy of the list with the changes.\n        // <small>No lists have been harmed in the application of this function.</small>\n        R.insert.all = curry3(function(index, elts, list) {\n            index = index < list.length && index >= 0 ? index : list.length;\n            return concat(concat(_slice(list, 0, index), elts), _slice(list, index));\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Makes a comparator function out of a function that reports whether the first element is less than the second.\n        //\n        //     var cmp = comparator(function(a, b) {\n        //         return a.age < b.age;\n        //     };\n        //     sort(cmp, people);\n        var comparator = R.comparator = function(pred) {\n            return function (a, b) {\n                return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n            };\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a copy of the list, sorted according to the comparator function, which should accept two values at a\n        // time and return a negative number if the first value is smaller, a positive number if it's larger, and zero\n        // if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.\n        var sort = R.sort = function(comparator, list) {\n            return arguments.length < 2 ?\n                function _sort(list) { return clone(list).sort(comparator); } :\n                clone(list).sort(comparator);\n        };\n\n        // Splits a list into sublists stored in an object, based on the result of calling a String-returning function\n        // on each element, and grouping the results according to values returned.\n        //\n        //     var byGrade = partition(function(student) {\n        //         var score = student.score\n        //         return (score < 65) ? 'F' : (score < 70) ? 'D' :\n        //                (score < 80) ? 'C' : (score < 90) ? 'B' : 'A';\n        //     };\n        //     var students = [{name: \"Abby\", score: 84} /*, ... */,\n        //                     {name: 'Jack', score: 69}];\n        //     byGrade(students);\n        //     //=> {\n        //     //   \"A\": [{name: 'Dianne', score: 99} /*, ... */],\n        //     //   \"B\": [{name: \"Abby\", score: 84} /*, ... */]\n        //     //   /*, ... */\n        //     //   \"F\": [{name: 'Eddy', score: 58}]\n        //     // }"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.partition = curry2(function (fn, list) {\n            return foldl(function (acc, elt) {\n                var key = fn(elt);\n                acc[key] = append(elt, acc[key] || (acc[key] = []));\n                return acc;\n            }, {}, list);\n        });\n        aliasFor(\"partition\").is(\"groupBy\");\n\n        // Object Functions\n        // ----------------\n        //\n        // These functions operate on plain Javascript object, adding simple functions to test properties on these\n        // objects.  Many of these are of most use in conjunction with the list functions, operating on lists of\n        // objects.\n\n        // --------",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "partition",
      "value": "curry2(function (fn, list) {",
      "string": "R.partition"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Runs the given function with the supplied object, then returns the object.\n        R.tap = curry2(function(x, fn) {\n            if (typeof fn === \"function\") { fn(x); }\n            return x;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Tests if two items are equal.  Equality is strict here, meaning reference equality for objects and\n        // non-coercing equality for primitives.\n        R.eq = function (a, b) {\n            return arguments.length < 2 ? function _eq(b) { return a === b; } : a === b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a function that when supplied an object returns the indicated property of that object, if it exists.\n        var prop = R.prop = function (p, obj) {\n            return arguments.length < 2 ? function _prop(obj) { return obj[p]; } :  obj[p];\n        };\n        aliasFor(\"prop\").is(\"nth\").and(\"get\"); // TODO: are we sure?  Matches some other libs, but might want to reserve for other use."
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a function that when supplied an object returns the result of running the indicated function on\n        // that object, if it has such a function.\n        R.func = function (fn, obj) {\n            function _func(obj) {\n                return obj[fn].apply(obj, _slice(arguments, 1));\n            }\n            return arguments.length < 2 ? _func : _func(obj);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a function that when supplied a property name returns that property on the indicated object, if it\n        // exists.\n        R.props = function (obj, prop) {\n            return arguments.length < 2 ? function _props(prop) { return obj && obj[prop]; } : obj && obj[prop];\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a function that always returns the given value.\n        var always = R.always = function (val) {\n            return function () {\n                return val;\n            };\n        };\n        aliasFor(\"always\").is(\"constant\").and(\"K\");"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var anyBlanks = R.any(function (val) {\n            return val === null || val === undef;\n        });\n\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var nativeKeys = Object.keys;",
    "ctx": {
      "type": "declaration",
      "name": "anyBlanks",
      "value": "R.any(function (val) {",
      "string": "anyBlanks"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a list containing the names of all the enumerable own\n        // properties of the supplied object.\n        var keys = R.keys = function (obj) {\n            if (nativeKeys) return nativeKeys(Object(obj));\n            var prop, ks = [];\n            for (prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    ks.push(prop);\n                }\n            }\n            return ks;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a list containing the names of all the\n        // properties of the supplied object, including prototype properties.\n        R.keysIn = function (obj) {\n            var prop, ks = [];\n            for (prop in obj) {\n                ks.push(prop);\n            }\n            return ks;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a list of all the enumerable own properties of the supplied object.\n        R.values = function (obj) {\n            var prop, props = keys(obj),\n                length = props.length,\n                vals = new Array(length);\n            for (var i = 0; i < length; i++) {\n                vals[i] = obj[props[i]];\n            }\n            return vals;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a list of all the properties, including prototype properties,\n        // of the supplied object.\n        R.valuesIn = function (obj) {\n            var prop, vs = [];\n            for (prop in obj) {\n                vs.push(obj[prop]);\n            }\n            return vs;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// internal helper function\n        function pickWith(test, obj) {\n            var copy = {},\n                props = keys(obj), prop, val;\n            for (var i = 0, len = props.length; i < len; i++) {\n                prop = props[i];\n                val = obj[prop];\n                if (test(val, prop, obj)) {\n                    copy[prop] = val;\n                }\n            }\n            return copy;\n        }"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the\n        // property is ignored\n        R.pick = curry2(function pick(names, obj) {\n            return pickWith(function(val, key) {\n                return contains(key, names);\n            }, obj);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns a partial copy of an object omitting the keys specified.\n        R.omit = curry2(function omit(names, obj) {\n            return pickWith(function(val, key) {\n                return !contains(key, names);\n            }, obj);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.pickWith = curry2(pickWith);",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "pickWith",
      "value": "curry2(pickWith)",
      "string": "R.pickWith"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.\n        var pickAll = function (names, obj) {\n            var copy = {};\n            each(function (name) {\n                copy[name] = obj[name];\n            }, names);\n            return copy;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.pickAll = curry2(pickAll);",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "pickAll",
      "value": "curry2(pickAll)",
      "string": "R.pickAll"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "The destination object."
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "other",
        "description": "The other object to merge with destination."
      },
      {
        "type": "returns",
        "string": "{Object} Returns the destination object. "
      },
      {
        "type": "example",
        "string": "extend({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n// => { 'name': 'fred', 'age': 40 }"
      }
    ],
    "description": {
      "full": "<p>Assigns own enumerable properties of the other object to the destination<br />object prefering items in other.</p>",
      "summary": "<p>Assigns own enumerable properties of the other object to the destination<br />object prefering items in other.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function extend(destination, other) {\n            var props = keys(other),\n                i = -1, length = props.length;\n            while (++i < length) {\n                destination[props[i]] = other[props[i]];\n            }\n            return destination;\n        }",
    "ctx": {
      "type": "function",
      "name": "extend",
      "string": "extend()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": ""
      },
      {
        "type": "memberOf",
        "parent": "R"
      },
      {
        "type": "category",
        "string": "Object"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "a",
        "description": "source object"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "b",
        "description": "object with higher precendence in output"
      },
      {
        "type": "returns",
        "string": "{Object} Returns the destination object. "
      },
      {
        "type": "example",
        "string": "mixin({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n// => { 'name': 'fred', 'age': 40 }"
      }
    ],
    "description": {
      "full": "<p>Create a new object with the own properties of a<br />merged with the own properties of object b.</p>",
      "summary": "<p>Create a new object with the own properties of a<br />merged with the own properties of object b.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "R.mixin = curry2(function(a, b) {\n            return extend(extend({}, a), b);\n        });",
    "ctx": {
      "type": "property",
      "receiver": "R",
      "name": "mixin",
      "value": "curry2(function(a, b) {",
      "string": "R.mixin"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Reports whether two functions have the same value for the specified property.  Useful as a curried predicate.\n        R.eqProps = function (prop, obj1, obj2) {\n            var f1 = function eqPropsCurried1(obj1, obj2) {\n                var f2 = function eqPropsCurried2(obj2) {\n                    return obj1[prop] === obj2[prop];\n                };\n                return arguments.length < 2 ? f2 : f2(obj2);\n            };\n            return arguments.length < 2 ? f1 :\n                arguments.length < 3 ? f1(obj1) :\n                    f1(obj1, obj2);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// internal helper for `where`\n        function satisfiesSpec(spec, parsedSpec, testObj) {\n            if (spec === testObj) { return true; }\n            if (testObj == null) { return false; }\n            parsedSpec.fn = parsedSpec.fn || [];\n            parsedSpec.obj = parsedSpec.obj || [];\n            var key, val, i = -1, fnLen = parsedSpec.fn.length, j = -1, objLen = parsedSpec.obj.length;\n            while (++i < fnLen) {\n                key = parsedSpec.fn[i];\n                val = spec[key];\n                //if (!hasOwnProperty.call(testObj, key)) {\n                //    return false;\n                //}\n                if (!(key in testObj)) {\n                    return false;\n                }\n                if (!val(testObj[key], testObj)) {\n                    return false;\n                }\n            }\n            while (++j < objLen) {\n                key = parsedSpec.obj[j];\n                if (spec[key] !== testObj[key]) {\n                    return false;\n                }\n            }\n            return true;\n        }"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// `where` takes a spec object and a test object and returns true if the test satisfies the spec.\n        // Any property on the spec that is not a function is interpreted as an equality\n        // relation. For example:\n        //\n        //     var spec = {x: 2};\n        //     where(spec, {w: 10, x: 2, y: 300}); // => true, x === 2\n        //     where(spec, {x: 1, y: 'moo', z: true}); // => false, x !== 2\n        //\n        // If the spec has a property mapped to a function, then `where` evaluates the function, passing in\n        // the test object's value for the property in question, as well as the whole test object. For example:\n        //\n        //     var spec = {x: function(val, obj) { return  val + obj.y > 10; };\n        //     where(spec, {x: 2, y: 7}); // => false\n        //     where(spec, {x: 3, y: 8}); // => true\n        //\n        // `where` is well suited to declarativley expressing constraints for other functions, e.g., `filter`:\n        //\n        //     var xs = [{x: 2, y: 1}, {x: 10, y: 2},\n        //               {x: 8, y: 3}, {x: 10, y: 4}];\n        //     var fxs = filter(where({x: 10}), xs);\n        //     // fxs ==> [{x: 10, y: 2}, {x: 10, y: 4}]\n        //\n        R.where = function where(spec, testObj) {\n            var parsedSpec = R.partition(function(key) {\n                    return typeof spec[key] === \"function\" ? \"fn\" : \"obj\";\n                }, keys(spec)\n            );\n            switch (arguments.length) {\n                case 0: throw NO_ARGS_EXCEPTION;\n                case 1:\n                    return function(testObj) {\n                        return satisfiesSpec(spec, parsedSpec, testObj);\n                    };\n            }\n            return satisfiesSpec(spec, parsedSpec, testObj);\n        };\n\n        // Miscellaneous Functions\n        // -----------------------\n        //\n        // A few functions in need of a good home.\n\n        // --------"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Expose the functions from ramda as properties on another object.  If the passed-in object is the\n        // global object, or the passed-in object is \"falsy\", then the ramda functions become global functions.\n        R.installTo = function(obj) {\n            return extend(obj || global, R);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function that always returns `0`.\n        R.alwaysZero = always(0);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function that always returns `false`.\n        R.alwaysFalse = always(false);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function that always returns `true`.\n        R.alwaysTrue = always(true);\n\n\n\n        // Logic Functions\n        // ---------------\n        //\n        // These functions are very simple wrappers around the built-in logical operators, useful in building up\n        // more complex functional forms.\n\n        // --------"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function wrapping calls to the two functions in an `&&` operation, returning `true` or `false`.  Note that\n        // this is short-circuited, meaning that the second function will not be invoked if the first returns a false-y\n        // value.\n        R.and = function(f, g) {\n           function _and(g) {\n               return function() {return !!(f.apply(this, arguments) && g.apply(this, arguments));};\n           }\n            return arguments.length < 2 ? _and : _and(g);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function wrapping calls to the two functions in an `||` operation, returning `true` or `false`.  Note that\n        // this is short-circuited, meaning that the second function will not be invoked if the first returns a truth-y\n        // value. (Note also that at least Oliver Twist can pronounce this one...)\n        R.or = function(f, g) { // TODO: arity?\n           function _or(g) {\n               return function() {return !!(f.apply(this, arguments) || g.apply(this, arguments));};\n           }\n            return arguments.length < 2 ? _or : _or(g);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A function wrapping a call to the given function in a `!` operation.  It will return `true` when the\n        // underlying function would return a false-y value, and `false` when it would return a truth-y one.\n        var not = R.not = function (f) {\n            return function() {return !f.apply(this, arguments);};\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Create a predicate wrapper which will call a pick function (all/any) for each predicate\n        var predicateWrap = function(predPicker) {\n            return function(preds"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>, args</p>",
      "summary": "<p>, args</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "{\n                var predIterator = function() {\n                    var args = arguments;\n                    return predPicker(function(predicate) {\n                        return predicate.apply(null, args);\n                    }, preds);\n                };\n                return arguments.length > 1 ?\n                        // Call function imediately if given arguments\n                        predIterator.apply(null, _slice(arguments, 1)) :\n                        // Return a function which will call the predicates with the provided arguments\n                        arity(max(pluck(\"length\", preds)), predIterator);\n            };\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Given a list of predicates returns a new predicate that will be true exactly when all of them are.\n        R.allPredicates = predicateWrap(all);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Given a list of predicates returns a new predicate that will be true exactly when any one of them is.\n        R.anyPredicates = predicateWrap(any);\n\n        // Arithmetic Functions\n        // --------------------\n        //\n        // These functions wrap up the certain core arithmetic operators\n\n        // --------"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Adds two numbers.  Automatic curried:\n        //\n        //     var add7 = add(7);\n        //     add7(10); // => 17\n        var add = R.add = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a + b; } :  a + b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Multiplies two numbers.  Automatically curried:\n        //\n        //     var mult3 = multiply(3);\n        //     mult3(7); // => 21\n        var multiply = R.multiply = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a * b; } :  a * b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Subtracts the second parameter from the first.  This is automatically curried, and while at times the curried\n        // version might be useful, often the curried version of `subtractN` might be what's wanted.\n        //\n        //     var complementaryAngle = subtract(90);\n        //     complementaryAngle(30) ; // => 60\n        var subtract = R.subtract = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a - b; } :  a - b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Reversed version of `subtract`, where first parameter is subtracted from the second.  The curried version of\n        // this one might me more useful than that of `subtract`.  For instance:\n        //\n        //     var decrement = subtractN(1);\n        //     decrement(10); // => 9;\n        R.subtractN = flip(subtract);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Divides the first parameter by the second.  This is automatically curried, and while at times the curried\n        // version might be useful, often the curried version of `divideBy` might be what's wanted.\n        var divide = R.divide = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a / b; } :  a / b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Reversed version of `divide`, where the second parameter is divided by the first.  The curried version of\n        // this one might be more useful than that of `divide`.  For instance:\n        //\n        //     var half = divideBy(2);\n        //     half(42); // => 21\n        R.divideBy = flip(divide);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Divides the second parameter by the first and returns the remainder.\n        var modulo = R.modulo = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a % b; } :  a % b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Reversed version of `modulo`, where the second parameter is divided by the first.  The curried version of\n        // this one might be more useful than that of `modulo`.  For instance:\n        //\n        //     var isOdd = moduloBy(2);\n        //     isOdd(42); // => 0\n        //     isOdd(21); // => 1\n        R.moduloBy = flip(modulo);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Adds together all the elements of a list.\n        R.sum = foldl(add, 0);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Multiplies together all the elements of a list.\n        R.product = foldl(multiply, 1);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns true if the first parameter is less than the second.\n        R.lt = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a < b; } :  a < b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns true if the first parameter is less than or equal to the second.\n        R.lte = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a <= b; } :  a <= b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns true if the first parameter is greater than the second.\n        R.gt = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a > b; } :  a > b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Returns true if the first parameter is greater than or equal to the second.\n        R.gte = function(a, b) {\n            return arguments.length < 2 ? function(b) { return a >= b; } :  a >= b;\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Determines the largest of a list of numbers (or elements that can be cast to numbers)\n        var max = R.max = function(list) {\n            return foldl(binary(Math.max), -Infinity, list);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Determines the largest of a list of items as determined by pairwise comparisons from the supplied comparator\n        R.maxWith = curry2(function(keyFn, list) {\n            if (!(list && list.length > 0)) {\n               return undef;\n            }\n            var idx = 0, winner = list[idx], max = keyFn(winner), testKey;\n            while (++idx < list.length) {\n                testKey = keyFn(list[idx]);\n                if (testKey > max) {\n                    max = testKey;\n                    winner = list[idx];\n                }\n            }\n            return winner;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// TODO: combine this with maxWith?\n\n        // Determines the smallest of a list of items as determined by pairwise comparisons from the supplied comparator\n        R.minWith = curry2(function(keyFn, list) {\n            if (!(list && list.length > 0)) {\n                return undef;\n            }\n            var idx = 0, winner = list[idx], min = keyFn(list[idx]), testKey;\n            while (++idx < list.length) {\n                testKey = keyFn(list[idx]);\n                if (testKey < min) {\n                    min = testKey;\n                    winner = list[idx];\n                }\n            }\n            return winner;\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Determines the smallest of a list of numbers (or elements that can be cast to numbers)\n        R.min = function(list) {\n            return foldl(binary(Math.min), Infinity, list);\n        };\n\n\n        // String Functions\n        // ----------------\n        //\n        // Much of the String.prototype API exposed as simple functions.\n\n        // --------"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// A substring of a String:\n        //\n        //     substring(2, 5, \"abcdefghijklm\"); //=> \"cde\"\n        var substring = R.substring = invoker(\"substring\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The trailing substring of a String starting with the nth character:\n        //\n        //     substringFrom(8, \"abcdefghijklm\"); //=> \"ijklm\"\n        R.substringFrom = flip(substring)(undef);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The leading substring of a String ending before the nth character:\n        //\n        //     substringTo(8, \"abcdefghijklm\"); //=> \"abcdefgh\"\n        R.substringTo = substring(0);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The character at the nth position in a String:\n        //\n        //     charAt(8, \"abcdefghijklm\"); //=> \"i\"\n        R.charAt = invoker(\"charAt\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The ascii code of the character at the nth position in a String:\n        //\n        //     charCodeAt(8, \"abcdefghijklm\"); //=> 105\n        //     // (... 'a' ~ 97, 'b' ~ 98, ... 'i' ~ 105)\n        R.charCodeAt = invoker(\"charCodeAt\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Tests a regular expression agains a String\n        //\n        //     match(/([a-z]a)/g, \"bananas\"); //=> [\"ba\", \"na\", \"na\"]\n        R.match = invoker(\"match\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Finds the index of a substring in a string, returning -1 if it's not present\n        //\n        //     strIndexOf('c', 'abcdefg) //=> 2\n        R.strIndexOf = invoker(\"indexOf\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Finds the last index of a substring in a string, returning -1 if it's not present\n        //\n        //     strLastIndexOf('a', 'banana split') //=> 5\n        R.strLastIndexOf = invoker(\"lastIndexOf\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The uppercase version of a string.\n        //\n        //     toUpperCase('abc') //=> 'ABC'\n        R.toUpperCase = invoker(\"toUpperCase\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The lowercase version of a string.\n        //\n        //     toLowerCase('XYZ') //=> 'xyz'\n        R.toLowerCase = invoker(\"toLowerCase\", String.prototype);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// The string split into substring at the specified token\n        //\n        //     split('.', 'a.b.c.xyz.d') //=>\n        //         ['a', 'b', 'c', 'xyz', 'd']\n        R.split = invoker(\"split\", String.prototype, 1);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// internal path function\n        // Takes an array, paths, indicating the deep set of keys\n        // to find. E.g.\n        // path(['a', 'b'], {a: {b: 2}}) // => 2\n        function path(paths, obj) {\n            var i = -1, length = paths.length, val;\n            while (obj != null && ++i < length) {\n                obj = val = obj[paths[i]];\n            }\n            return val;\n        }"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Retrieve a computed path by a function, fn. Fn will be given\n        // a string, str which it will use to compute the path\n        // e.g. fn(\"a.b\") => [\"a\", \"b\"]\n        // This path will be looked up on the object\n        R.pathWith = curry3(function pathWith(fn, str, obj) {\n            var paths = fn(str) || [];\n            return path(paths, obj);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Retrieve a value on an object from a deep path, str\n        // different properties on nested objects are indicated in string\n        // by a seperator, sep\n        // R.pathOn(\"|\", \"a|b\", {a: {b: 2}}) // => 2\n        R.pathOn = curry3(function pathOn(sep, str, obj) {\n            return path(str.split(sep), obj);\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Retrieve a nested path on an object seperated by periods\n        // R.path('a.b'], {a: {b: 2}}) // => 2\n        R.path = R.pathOn('.');\n\n        // Data Analysis and Grouping Functions\n        // ------------------------------------\n        //\n        // Functions performing SQL-like actions on lists of objects.  These do not have any SQL-like optimizations\n        // performed on them, however.\n\n        // --------"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Reasonable analog to SQL `select` statement.\n        //\n        //     var kids = [\n        //         {name: 'Abby', age: 7, hair: 'blond', grade: 2},\n        //         {name: 'Fred', age: 12, hair: 'brown', grade: 7}\n        //     ];\n        //     project(['name', 'grade'], kids);\n        //     //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n        R.project = useWith(map, R.pickAll, identity); // passing `identity` gives correct arity"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Determines whether the given property of an object has a specific value\n        // Most likely used to filter a list:\n        //\n        //     var kids = [\n        //       {name: 'Abby', age: 7, hair: 'blond'},\n        //       {name: 'Fred', age: 12, hair: 'brown'},\n        //       {name: 'Rusty', age: 10, hair: 'brown'},\n        //       {name: 'Alois', age: 15, disposition: 'surly'}\n        //     ];\n        //     filter(propEq(\"hair\", \"brown\"), kids);\n        //     //=> Fred and Rusty\n        R.propEq = function (name, val, obj) {\n            var f1 = function propEqCurried1(val, obj) {\n                var f2 = function propEqCurried2(obj) {\n                    return obj[name] === val;\n                };\n                return arguments.length < 2 ? f2 : f2(obj);\n            };\n            return arguments.length < 2 ? f1 :\n                arguments.length < 3 ? f1(val) :\n                    f1(val, obj);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.\n        R.union = compose(uniq, R.concat);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is\n        // determined according to the value returned by applying the supplied predicate to two list elements.\n        R.unionWith = curry3(function (pred, list1, list2) {\n            return uniqWith(pred, concat(list1, list2));\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n        R.difference = curry2(function(first, second) {\n            return uniq(reject(flip(contains)(second), first));\n        });"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n        // Duplication is determined according to the value returned by applying the supplied predicate to two list\n        // elements.\n        R.differenceWith = function (pred, first, second) {\n            var f1 = function differenceWithCurried1(first, second) {\n                var f2 = function differenceWithCurried2(second) {\n                    return uniqWith(pred)(reject(flip(R.containsWith(pred))(second), first));\n                };\n                return arguments.length < 2 ? f2 : f2(second);\n            };\n            return arguments.length < 2 ? f1 :\n                arguments.length < 3 ? f1(first) :\n                    f1(first, second);\n        };\n\n        // Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.\n        R.intersection = function(list1, list2) {\n            function _intersection(list2) {\n                return uniq(filter(flip(contains)(list1), list2));\n            }\n            return arguments.length < 2 ? _intersection : _intersection(list2);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.\n        // Duplication is determined according to the value returned by applying the supplied predicate to two list\n        // elements.\n        R.intersectionWith = function (pred, list1, list2) {\n            var f1 = function intersectionWithCurried1(list1, list2) {\n                var f2 = function intersectionWithCurried2(list2) {\n                    var results = [], idx = -1;\n                    while (++idx < list1.length) {\n                        if (containsWith(pred, list1[idx], list2)) {\n                            results[results.length] = list1[idx];\n                        }\n                    }\n                    return uniqWith(pred, results);\n                };\n                return arguments.length < 2 ? f2 : f2(list2);\n            };\n            return arguments.length < 2 ? f1 :\n                arguments.length < 3 ? f1(list1) :\n                    f1(list1, list2);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Creates a new list whose elements each have two properties: `val` is the value of the corresponding\n        // item in the list supplied, and `key` is the result of applying the supplied function to that item.\n        var keyValue = function(fn, list) { // TODO: Should this be made public?\n            function _keyValue(list) {\n                return map(function(item) {return {key: fn(item), val: item};}, list);\n            }\n            return arguments.length < 2 ? _keyValue : _keyValue(list);\n        };"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Sorts the list according to a key generated by the supplied function.\n        R.sortBy = function(fn, list) {"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>return sort(comparator(function(a, b) {return fn(a) &lt; fn(b);}), list); // clean, but too time-inefficient<br />              return pluck(&quot;val&quot;, sort(comparator(function(a, b) {return a.key &lt; b.key;}), keyValue(fn, list))); // nice, but no need to clone result of keyValue call, so...</p>",
      "summary": "<p>return sort(comparator(function(a, b) {return fn(a) &lt; fn(b);}), list); // clean, but too time-inefficient<br />              return pluck(&quot;val&quot;, sort(comparator(function(a, b) {return a.key &lt; b.key;}), keyValue(fn, list))); // nice, but no need to clone result of keyValue call, so...</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function _sortBy(list) {\n                return pluck(\"val\", keyValue(fn, list).sort(comparator(function(a, b) {return a.key < b.key;})));\n            }\n            return arguments.length < 2 ? _sortBy : _sortBy(list);\n        };",
    "ctx": {
      "type": "function",
      "name": "_sortBy",
      "string": "_sortBy()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>TODO: JSDoc-style documentation for this function</p>",
      "summary": "<p>TODO: JSDoc-style documentation for this function</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "// Counts the elements of a list according to how many match each value of a key generated by the supplied function.\n        R.countBy = function(fn, list) {\n            function _countBy(list) {\n                return foldl(function(counts, obj) {\n                    counts[obj.key] = (counts[obj.key] || 0) + 1;\n                    return counts;\n                }, {}, keyValue(fn, list));\n            }\n            return arguments.length < 2 ? _countBy : _countBy(list);\n        };\n\n        // All the functional goodness, wrapped in a nice little package, just for you!\n        return R;\n    }());\n}));"
  }
]